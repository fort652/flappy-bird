<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flappy Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      canvas {
        display: block;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }

      .game-over {
        background: rgba(0, 0, 0, 0.8);
      }

      .countdown-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        pointer-events: none;
      }

      .countdown-number {
        font-size: 120px;
        font-weight: bold;
        color: #fbbf24;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
        animation: countdownPulse 0.5s ease-out;
      }

      .countdown-text {
        font-size: 32px;
        color: white;
        margin-top: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      @keyframes countdownPulse {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      canvas {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        outline: none;
      }

      * {
        -webkit-tap-highlight-color: transparent;
      }
    </style>
  </head>
  <body
    class="m-0 p-0 font-sans bg-gradient-to-br from-sky-300 to-green-200 flex justify-center items-center min-h-screen overflow-hidden"
  >
    <div class="relative rounded-3xl shadow-2xl overflow-hidden">
      <canvas id="gameCanvas" class="w-screen h-screen"></canvas>

      <div
        class="absolute inset-0 pointer-events-none flex flex-col justify-between p-5"
      >
        <div
          class="text-center text-5xl font-bold text-white drop-shadow-lg mt-5"
          id="score"
        >
          0
        </div>
      </div>

      <div
        class="countdown-overlay"
        id="countdownOverlay"
        style="display: none"
      >
        <div class="countdown-number" id="countdownNumber">3</div>
        <div class="countdown-text">Get Ready!</div>
      </div>

      <div
        class="game-over flex flex-col items-center justify-center gap-6 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white p-6 rounded-2xl text-center hidden"
        id="gameOver"
      >
        <h2 class="text-3xl mb-3 text-red-400">Game Over!</h2>
        <p class="text-base mb-4">
          Final Score: <span id="finalScore">0</span>
        </p>
        <div class="flex flex-col gap-3">
          <play-button
            title="Play Again"
            route="game.html"
            image="assets/images/reload.png"
          ></play-button>
          <play-button
            title="Go Home"
            route="../index.html"
            image="assets/images/back.png"
          ></play-button>
        </div>
      </div>
    </div>

    <script type="module">
      import "../components/PlayButton.js";
    </script>

    <script>
      let CANVAS_WIDTH, CANVAS_HEIGHT;
      const GRAVITY = 0.6;
      const FLAP_SPEED = -8;
      const PIPE_WIDTH = 80;
      const PIPE_GAP = 200;
      const PIPE_SPEED = 2;
      const PIPE_SPAWN_RATE = 2000;

      // Game state
      let canvas, ctx;
      let gameRunning = false;
      let countdownActive = false;
      let countdownValue = 3;
      let score = 0;
      let highScore = localStorage.getItem("flappyBirdHighScore") || 0;
      let gameStartTime = 0;
      let gameStats = {};

      const bird = {
        x: 150,
        y: CANVAS_HEIGHT / 2,
        velocity: 0,
        size: 20,
        color: "#FFD700",
        character: "default",
        specialEffects: [],
      };

      let pipes = [];

      let lastTime = 0;
      let pipeSpawnTimer = 0;

      let audioContext;
      let masterVolume = 0.8;
      let soundEffects = true;
      let bgMusic = true;
      let musicVolume = 0.6;
      let currentAudioSource = null; // Track current playing audio
      let gameStartAudioSource = null; // Track the game start audio

      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        loadGameSettings();
        loadGameProgress();

        initAudio();

        document.addEventListener("keydown", handleKeyDown);
        canvas.addEventListener("click", handleClick);
        window.addEventListener("resize", handleResize);

        startGame();
      }

      function loadGameSettings() {
        const saved = localStorage.getItem("flappyBirdSettings");
        if (saved) {
          const settings = JSON.parse(saved);
          masterVolume = settings.masterVolume / 100;
          soundEffects = settings.soundEffects;
          bgMusic = settings.bgMusic;
          musicVolume = settings.musicVolume / 100;
        }
      }

      function loadGameProgress() {
        const saved = localStorage.getItem("flappyBirdProgress");
        if (saved) {
          const progress = JSON.parse(saved);
          bird.character = progress.currentCharacter || "default";
        }

        const savedCharacter = localStorage.getItem("flappyBirdCharacter");
        if (savedCharacter) {
          bird.character = savedCharacter;
        }
      }

      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          
          testMP3Load();
        } catch (e) {
          console.log("Audio not supported");
        }
      }

      function testMP3Load() {
        fetch("assets/sounds/8bit1.mp3")
          .then(response => {
            console.log("MP3 test - Status:", response.status, "OK:", response.ok);
            if (response.ok) {
              console.log("MP3 file is accessible");
            } else {
              console.error("MP3 file not accessible:", response.status);
            }
          })
          .catch(error => {
            console.error("MP3 test failed:", error);
          });
      }

      function playSound(frequency, duration, type = "sine") {
        if (!soundEffects || !audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(
          frequency,
          audioContext.currentTime
        );

        gainNode.gain.setValueAtTime(
          0.1 * masterVolume,
          audioContext.currentTime
        );
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + duration
        );

        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
      }

      function playMP3Sound(audioPath, onSourceCreated = null) {
        if (!soundEffects || !audioContext) {
          console.log("Sound effects disabled or audio context not available");
          return null;
        }

        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        console.log("Attempting to play MP3:", audioPath);

        // Stop any currently playing audio before starting new one
        stopCurrentAudio();

        fetch(audioPath)
          .then(response => {
            console.log("Fetch response status:", response.status);
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.arrayBuffer();
          })
          .then(arrayBuffer => {
            console.log("Audio file loaded, size:", arrayBuffer.byteLength);
            return audioContext.decodeAudioData(arrayBuffer);
          })
          .then(audioBuffer => {
            console.log("Audio decoded successfully, duration:", audioBuffer.duration);
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = audioBuffer;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(
              0.5 * masterVolume,
              audioContext.currentTime + 0.1
            );

            source.start();
            console.log("MP3 sound started playing:", audioPath);
            
            // Store the audio source for potential stopping
            currentAudioSource = source;
            
            // Call the callback if provided
            if (onSourceCreated) {
              onSourceCreated(source);
            }
          })
          .catch(error => {
            console.error("Error loading audio file:", error);
            console.log("Falling back to generated sound");
          });
      }

      function stopCurrentAudio() {
        if (currentAudioSource) {
          try {
            console.log("Stopping current audio source");
            currentAudioSource.stop();
            currentAudioSource = null;
            console.log("Current audio stopped successfully");
          } catch (error) {
            console.log("Current audio already stopped or finished:", error.message);
            currentAudioSource = null;
          }
        } else {
          console.log("No current audio source to stop");
        }
      }

      function stopGameStartAudio() {
        if (gameStartAudioSource) {
          try {
            console.log("Stopping game start audio source");
            gameStartAudioSource.stop();
            gameStartAudioSource = null;
            console.log("Game start audio stopped successfully");
          } catch (error) {
            console.log("Game start audio already stopped or finished:", error.message);
            gameStartAudioSource = null;
          }
        } else {
          console.log("No game start audio source to stop");
        }
      }

      function stopAllAudio() {
        console.log("Stopping all audio sources");
        stopCurrentAudio();
        stopGameStartAudio();
      }

      function forcePlayAudio(audioPath) {
        console.log("Force playing audio:", audioPath);
        stopAllAudio();
        playMP3Sound(audioPath);
      }

      function handleResize() {
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
      }

      function startGame() {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log("Audio context resumed");
          });
        }

        // Stop any currently playing audio when starting a new game
        console.log("Starting new game - stopping all audio");
        stopAllAudio();

        gameRunning = false;
        countdownActive = true;
        countdownValue = 3;
        score = 0;
        gameStartTime = Date.now();
        bird.y = CANVAS_HEIGHT / 2;
        bird.velocity = 0;
        pipes = [];
        pipeSpawnTimer = 0;
        bird.specialEffects = [];

        document.getElementById("score").textContent = "0";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("countdownOverlay").style.display = "block";

        startCountdown();
      }

      function startCountdown() {
        updateCountdownDisplay();

        const countdownRenderLoop = () => {
          if (countdownActive) {
            renderCountdown();
            requestAnimationFrame(countdownRenderLoop);
          }
        };
        countdownRenderLoop();

        const countdownInterval = setInterval(() => {
          countdownValue--;
          updateCountdownDisplay();

          if (countdownValue <= 0) {
            clearInterval(countdownInterval);
            endCountdown();
          }
        }, 1000);
      }

      function updateCountdownDisplay() {
        const countdownNumber = document.getElementById("countdownNumber");
        const countdownText = document.querySelector(".countdown-text");

        if (countdownValue > 0) {
          countdownNumber.textContent = countdownValue;
          countdownText.textContent = "Get Ready!";

        } else {
          countdownNumber.textContent = "GO!";
          countdownText.textContent = "Start Flying!";

          // Play game start sound and track the source
          console.log("Playing game start sound (8bit1)");
          playMP3Sound("assets/sounds/8bit1.mp3", (source) => {
            console.log("Game start audio source created:", source);
            gameStartAudioSource = source;
          });
        }
      }

      function endCountdown() {
        countdownActive = false;
        gameRunning = true;

        // Stop the game start audio when the game actually starts
        stopGameStartAudio();

        setTimeout(() => {
          document.getElementById("countdownOverlay").style.display = "none";
        }, 1000);

        gameLoop();
      }

      function restartGame() {
        document.getElementById("gameOver").style.display = "none";

        // Stop any current audio before restarting
        stopCurrentAudio();

        startGame();
      }

      function goHome() {
        // Stop any current audio when leaving the game
        stopCurrentAudio();
        stopGameStartAudio();

        if (window.location.pathname.includes("/")) {
          window.location.href = "../index.html";
        } else {
          window.location.href = "index.html";
        }
      }

      function handleKeyDown(e) {
        if (e.code === "Space" && gameRunning) {
          e.preventDefault();
          flap();
        }
      }

      function handleClick() {
        if (gameRunning) {
          flap();
        }
      }

      function flap() {
        bird.velocity = FLAP_SPEED;

        addSpecialEffects();
      }

      function addSpecialEffects() {
        switch (bird.character) {
          case "rainbow":
            bird.specialEffects.push({
              type: "rainbow",
              x: bird.x,
              y: bird.y,
              life: 30,
            });
            break;
          case "ninja":
            bird.specialEffects.push({
              type: "stealth",
              x: bird.x,
              y: bird.y,
              life: 20,
            });
            break;
        }
      }

      function updateBird(deltaTime) {
        bird.velocity += GRAVITY;
        bird.y += bird.velocity;

        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = 0;
        }
        if (bird.y > CANVAS_HEIGHT - bird.size) {
          gameOver();
        }

        bird.specialEffects = bird.specialEffects.filter((effect) => {
          effect.life--;
          return effect.life > 0;
        });
      }

      function updatePipes(deltaTime) {
        pipeSpawnTimer += deltaTime;
        if (pipeSpawnTimer > PIPE_SPAWN_RATE) {
          spawnPipe();
          pipeSpawnTimer = 0;
        }

        for (let i = pipes.length - 1; i >= 0; i--) {
          const pipe = pipes[i];
          pipe.x -= PIPE_SPEED;

          if (pipe.x + PIPE_WIDTH < 0) {
            pipes.splice(i, 1);
            continue;
          }

          if (checkCollision(bird, pipe)) {
            gameOver();
            return;
          }

          if (!pipe.passed && pipe.x + PIPE_WIDTH < bird.x) {
            pipe.passed = true;
            score++;

            if (bird.character === "golden") {
              score++;
            }

            document.getElementById("score").textContent = score;

            checkAchievements();
          }
        }
      }

      function spawnPipe() {
        const gapY = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 100) + 50;
        pipes.push({
          x: CANVAS_WIDTH,
          gapY: gapY,
          passed: false,
        });
      }

      function checkCollision(bird, pipe) {
        let effectiveSize = bird.size;
        if (bird.character === "mini") effectiveSize *= 0.6;
        if (bird.character === "giant") effectiveSize *= 1.5;

        return (
          bird.x + effectiveSize > pipe.x &&
          bird.x < pipe.x + PIPE_WIDTH &&
          (bird.y < pipe.gapY || bird.y + effectiveSize > pipe.gapY + PIPE_GAP)
        );
      }

      function checkAchievements() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        if (score >= 10 && !unlocked.has("score_10")) {
          unlockAchievement("score_10", "Getting Started");
          unlockCharacter("blue");
        }
        if (score >= 25 && !unlocked.has("score_25")) {
          unlockAchievement("score_25", "Rising Star");
          unlockCharacter("purple");
          unlockBackground("winter");
        }
        if (score >= 50 && !unlocked.has("score_50")) {
          unlockAchievement("score_50", "Bird Master");
          unlockBackground("galaxy");
        }
        if (score >= 75 && !unlocked.has("score_75")) {
          unlockAchievement("score_75", "Advanced Player");
          unlockBackground("autumn");
        }
        if (score >= 100 && !unlocked.has("score_100")) {
          unlockAchievement("score_100", "Legendary Bird");
          unlockBackground("space");
          unlockCharacter("golden");
        }
        if (score >= 150 && !unlocked.has("score_150")) {
          unlockAchievement("score_150", "Master Flier");
          unlockBackground("space");
        }
        if (score >= 200 && !unlocked.has("score_200")) {
          unlockAchievement("score_200", "Ultimate Legend");
          unlockBackground("space");
        }

        if (stats.gamesPlayed === 1 && !unlocked.has("first_flight")) {
          unlockAchievement("first_flight", "First Flight");
          unlockCharacter("blue");
        }
      }

      function unlockAchievement(id, title) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlocked) progress.unlocked = [];
        if (!progress.unlocked.includes(id)) {
          progress.unlocked.push(id);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));

          showAchievementNotification(title);

          console.log(`Achievement unlocked: ${title}`);
        }
      }

      function unlockCharacter(characterId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedCharacters.includes(characterId)) {
          progress.unlockedCharacters.push(characterId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Character unlocked: ${characterId}`);
        }
      }

      function unlockBackground(backgroundId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        if (!progress.unlockedBackgrounds.includes(backgroundId)) {
          progress.unlockedBackgrounds.push(backgroundId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Background unlocked: ${backgroundId}`);
        }
      }

      function showAchievementNotification(title) {
        const notification = document.createElement("div");
        notification.className =
          "fixed top-20 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-3 rounded-full font-bold z-50 animate-bounce";
        notification.textContent = `🏆 ${title} Unlocked!`;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      function gameOver() {
        gameRunning = false;

        const gameDuration = Date.now() - gameStartTime;
        const distance = score * 100;

        if (score > highScore) {
          highScore = score;
          localStorage.setItem("flappyBirdHighScore", highScore);
        }

        saveGameStats(score, gameDuration, distance);

        document.getElementById("finalScore").textContent = score;
        document.getElementById("gameOver").style.display = "block";

        // Stop any current audio and play game over sound
        console.log("Game over - stopping current audio and playing 8bit3");
        stopAllAudio();
        playMP3Sound("assets/sounds/8bit3.mp3");
      }

      function saveGameStats(score, duration, distance) {
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
        stats.highScore = Math.max(stats.highScore || 0, score);
        stats.totalScore = (stats.totalScore || 0) + score;
        stats.totalTime = (stats.totalTime || 0) + duration;
        stats.totalDistance = (stats.totalDistance || 0) + distance;

        const today = new Date().toDateString();
        if (!stats.lastPlayed) {
          stats.lastPlayed = today;
          stats.consecutiveDays = 1;
        } else if (stats.lastPlayed !== today) {
          const lastPlayed = new Date(stats.lastPlayed);
          const currentDate = new Date(today);
          const diffTime = currentDate - lastPlayed;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          if (diffDays === 1) {
            stats.consecutiveDays = (stats.consecutiveDays || 0) + 1;
          } else {
            stats.consecutiveDays = 1;
          }
          stats.lastPlayed = today;
        }

        if (score > 0) {
          stats.perfectRuns = (stats.perfectRuns || 0) + 1;
        }

        if (!stats.recentGames) stats.recentGames = [];
        if (!stats.scoreHistory) stats.scoreHistory = [];

        stats.recentGames.unshift({
          score,
          duration,
          distance,
          timestamp: Date.now(),
          character: bird.character,
        });

        stats.scoreHistory.push(score);

        if (stats.recentGames.length > 50) {
          stats.recentGames = stats.recentGames.slice(0, 50);
        }

        localStorage.setItem("flappyBirdStats", JSON.stringify(stats));

        checkAchievementsAfterGame(stats);
      }

      function checkAchievementsAfterGame(stats) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);


        if (stats.gamesPlayed >= 10 && !unlocked.has("games_10")) {
          unlockAchievement("games_10", "Dedicated Player");
          unlockBackground("ocean");
        }
        if (stats.gamesPlayed >= 25 && !unlocked.has("games_25")) {
          unlockAchievement("games_25", "Regular Player");
          unlockBackground("forest");
        }
        if (stats.gamesPlayed >= 50 && !unlocked.has("games_50")) {
          unlockAchievement("games_50", "Veteran Player");
          unlockBackground("mountain");
        }
        if (stats.gamesPlayed >= 100 && !unlocked.has("games_100")) {
          unlockAchievement("games_100", "Ultimate Player");
          unlockBackground("city");
        }

        if (stats.perfectRuns >= 5 && !unlocked.has("perfect_5")) {
          unlockAchievement("perfect_5", "Perfect Player");
          unlockBackground("city");
          unlockCharacter("ninja");
        }
        if (stats.perfectRuns >= 10 && !unlocked.has("perfect_10")) {
          unlockAchievement("perfect_10", "Perfect Master");
          unlockCharacter("ninja");
        }

        if (stats.consecutiveDays >= 7 && !unlocked.has("daily_player")) {
          unlockAchievement("daily_player", "Daily Player");
          unlockBackground("rainbow");
          unlockCharacter("rainbow");
        }

        if (stats.totalDistance >= 10000 && !unlocked.has("distance_10k")) {
          unlockAchievement("distance_10k", "Long Distance Flier");
          unlockBackground("desert");
        }
      }

      function renderBird() {
        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        let effectiveSize = bird.size;
        let effectiveColor = bird.color;

        switch (bird.character) {
          case "blue":
            effectiveColor = "#3B82F6";
            effectiveSize *= 0.9;
            break;
          case "purple":
            effectiveColor = "#8B5CF6";
            effectiveSize *= 0.8;
            break;
          case "mini":
            effectiveSize *= 0.6;
            break;
          case "giant":
            effectiveSize *= 1.5;
            break;
        }

        ctx.fillStyle = effectiveColor;
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize / 2,
          bird.y + effectiveSize / 2,
          effectiveSize / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize * 0.7,
          bird.y + effectiveSize * 0.3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#FFA500";
        ctx.beginPath();
        ctx.ellipse(
          bird.x + effectiveSize * 0.3,
          bird.y + effectiveSize * 0.5,
          8,
          4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();

        renderSpecialEffects();

        ctx.restore();
      }

      function renderSpecialEffects() {
        bird.specialEffects.forEach((effect) => {
          switch (effect.type) {
            case "rainbow":
              ctx.strokeStyle = `hsl(${(Date.now() * 0.1) % 360}, 100%, 50%)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
              ctx.stroke();
              break;
            case "stealth":
              ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 40, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
        });
      }

      function renderPipes() {
        ctx.fillStyle = "#228B22";

        pipes.forEach((pipe) => {
          ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.gapY);

          ctx.fillRect(
            pipe.x,
            pipe.gapY + PIPE_GAP,
            PIPE_WIDTH,
            CANVAS_HEIGHT - pipe.gapY - PIPE_GAP
          );

          ctx.fillStyle = "#006400";
          ctx.fillRect(pipe.x - 5, pipe.gapY - 20, PIPE_WIDTH + 10, 20);
          ctx.fillRect(pipe.x - 5, pipe.gapY + PIPE_GAP, PIPE_WIDTH + 10, 20);
          ctx.fillStyle = "#228B22";
        });
      }

      function renderBackground() {
        const selectedBackground =
          localStorage.getItem("flappyBirdBackground") || "default";
        const backgroundImage = new Image();
        backgroundImage.src = `assets/images/${selectedBackground}.jpg`;

        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        for (let i = 0; i < 5; i++) {
          const x = ((Date.now() * 0.02 + i * 200) % (CANVAS_WIDTH + 100)) - 50;
          const y = 50 + i * 80;
          drawCloud(x, y, 60 + i * 10);
        }
      }

      function drawCloud(x, y, size) {
        ctx.beginPath();
        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.4, y, size * 0.6, 0, Math.PI * 2);
        ctx.arc(x + size * 0.8, y, size * 0.4, 0, Math.PI * 2);
        ctx.arc(x + size * 0.6, y + size * 0.2, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.2, y + size * 0.1, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      function gameLoop(currentTime = 0) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        updateBird(deltaTime);
        updatePipes(deltaTime);

        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        renderBackground();
        renderPipes();
        renderBird();

        requestAnimationFrame(gameLoop);
      }

      function renderBirdStatic() {
        let effectiveSize = bird.size;
        let effectiveColor = bird.color;

        switch (bird.character) {
          case "blue":
            effectiveColor = "#3B82F6";
            effectiveSize *= 0.9;
            break;
          case "purple":
            effectiveColor = "#8B5CF6";
            effectiveSize *= 0.8;
            break;
          case "mini":
            effectiveSize *= 0.6;
            break;
          case "giant":
            effectiveSize *= 1.5;
            break;
        }

        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        ctx.fillStyle = effectiveColor;
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize / 2,
          bird.y + effectiveSize / 2,
          effectiveSize / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize * 0.7,
          bird.y + effectiveSize * 0.3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#FFA500";
        ctx.beginPath();
        ctx.ellipse(
          bird.x + effectiveSize * 0.3,
          bird.y + effectiveSize * 0.5,
          8,
          4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.restore();
      }

      function renderCountdown() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        renderBackground();

        renderBirdStatic();

        renderPipes();
      }

      window.addEventListener("load", init);
    </script>
  </body>
</html>
