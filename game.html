<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flappy Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Custom styles that can't be easily replicated with Tailwind */
      canvas {
        display: block;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }

      .game-over {
        background: rgba(0, 0, 0, 0.8);
      }

      .countdown-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        pointer-events: none;
      }

      .countdown-number {
        font-size: 120px;
        font-weight: bold;
        color: #fbbf24;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
        animation: countdownPulse 0.5s ease-out;
      }

      .countdown-text {
        font-size: 32px;
        color: white;
        margin-top: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      @keyframes countdownPulse {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Remove touch feedback effects */
      canvas {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        outline: none;
      }

      /* Ensure no unwanted outlines or borders */
      * {
        -webkit-tap-highlight-color: transparent;
      }
    </style>
  </head>
  <body
    class="m-0 p-0 font-sans bg-gradient-to-br from-sky-300 to-green-200 flex justify-center items-center min-h-screen overflow-hidden"
  >
    <div class="relative rounded-3xl shadow-2xl overflow-hidden">
      <canvas id="gameCanvas" class="w-screen h-screen"></canvas>

      <div
        class="absolute inset-0 pointer-events-none flex flex-col justify-between p-5"
      >
        <div
          class="text-center text-5xl font-bold text-white drop-shadow-lg mt-5"
          id="score"
        >
          0
        </div>
      </div>

      <!-- Countdown Overlay -->
      <div
        class="countdown-overlay"
        id="countdownOverlay"
        style="display: none"
      >
        <div class="countdown-number" id="countdownNumber">3</div>
        <div class="countdown-text">Get Ready!</div>
      </div>

      <div
        class="game-over flex flex-col items-center justify-center gap-6 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white p-6 rounded-2xl text-center hidden"
        id="gameOver"
      >
        <h2 class="text-3xl mb-3 text-red-400">Game Over!</h2>
        <p class="text-base mb-4">
          Final Score: <span id="finalScore">0</span>
        </p>
        <div class="flex flex-col gap-3">
          <play-button
            title="Play Again"
            route="game.html"
            image="assets/images/reload.png"
          ></play-button>
          <play-button
            title="Go Home"
            route="../index.html"
            image="assets/images/back.png"
          ></play-button>
        </div>
      </div>
    </div>

    <script type="module">
      import "../components/PlayButton.js";
    </script>

    <script>
      // Game constants - now dynamic based on screen size
      let CANVAS_WIDTH, CANVAS_HEIGHT;
      const GRAVITY = 0.6;
      const FLAP_SPEED = -8;
      const PIPE_WIDTH = 80;
      const PIPE_GAP = 200;
      const PIPE_SPEED = 2;
      const PIPE_SPAWN_RATE = 2000;

      // Game state
      let canvas, ctx;
      let gameRunning = false;
      let countdownActive = false;
      let countdownValue = 3;
      let score = 0;
      let highScore = localStorage.getItem("flappyBirdHighScore") || 0;
      let gameStartTime = 0;
      let gameStats = {};

      // Bird object with character support
      const bird = {
        x: 150,
        y: CANVAS_HEIGHT / 2,
        velocity: 0,
        size: 20,
        color: "#FFD700",
        character: "default",
        specialEffects: [],
      };

      // Pipes array
      let pipes = [];

      // Game loop variables
      let lastTime = 0;
      let pipeSpawnTimer = 0;

      // Audio system
      let audioContext;
      let masterVolume = 0.8;
      let soundEffects = true;
      let bgMusic = true;
      let musicVolume = 0.6;

      // Initialize game
      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        // Set canvas dimensions to screen size
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Load game settings and progress
        loadGameSettings();
        loadGameProgress();

        // Initialize audio
        initAudio();

        // Event listeners
        document.addEventListener("keydown", handleKeyDown);
        canvas.addEventListener("click", handleClick);
        window.addEventListener("resize", handleResize);

        startGame();
      }

      // Load game settings
      function loadGameSettings() {
        const saved = localStorage.getItem("flappyBirdSettings");
        if (saved) {
          const settings = JSON.parse(saved);
          masterVolume = settings.masterVolume / 100;
          soundEffects = settings.soundEffects;
          bgMusic = settings.bgMusic;
          musicVolume = settings.musicVolume / 100;
        }
      }

      // Load game progress
      function loadGameProgress() {
        const saved = localStorage.getItem("flappyBirdProgress");
        if (saved) {
          const progress = JSON.parse(saved);
          bird.character = progress.currentCharacter || "default";
        }

        const savedCharacter = localStorage.getItem("flappyBirdCharacter");
        if (savedCharacter) {
          bird.character = savedCharacter;
        }
      }

      // Initialize audio system
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          
          // Test if we can load the MP3 file
          testMP3Load();
          
          if (bgMusic) {
            // playBackgroundMusic();
          }
        } catch (e) {
          console.log("Audio not supported");
        }
      }

      // Test MP3 loading
      function testMP3Load() {
        fetch("assets/sounds/8bit1.mp3")
          .then(response => {
            console.log("MP3 test - Status:", response.status, "OK:", response.ok);
            if (response.ok) {
              console.log("MP3 file is accessible");
            } else {
              console.error("MP3 file not accessible:", response.status);
            }
          })
          .catch(error => {
            console.error("MP3 test failed:", error);
          });
      }

      // Play background music
      function playBackgroundMusic() {
        if (!bgMusic || !audioContext) return;

        // Create a simple 8-bit style background music
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = "square";
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);

        gainNode.gain.setValueAtTime(
          musicVolume * masterVolume,
          audioContext.currentTime
        );

        oscillator.start();

        // Simple melody pattern
        const notes = [440, 494, 523, 587, 659, 587, 523, 494];
        let noteIndex = 0;

        setInterval(() => {
          if (bgMusic && gameRunning) {
            oscillator.frequency.setValueAtTime(
              notes[noteIndex],
              audioContext.currentTime
            );
            noteIndex = (noteIndex + 1) % notes.length;
          }
        }, 1000);
      }

      // Play sound effect
      function playSound(frequency, duration, type = "sine") {
        if (!soundEffects || !audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(
          frequency,
          audioContext.currentTime
        );

        gainNode.gain.setValueAtTime(
          0.1 * masterVolume,
          audioContext.currentTime
        );
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + duration
        );

        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
      }

      // Play MP3 sound effect
      function playMP3Sound(audioPath) {
        if (!soundEffects || !audioContext) {
          console.log("Sound effects disabled or audio context not available");
          return;
        }

        // Resume audio context if it's suspended
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        console.log("Attempting to play MP3:", audioPath);

        fetch(audioPath)
          .then(response => {
            console.log("Fetch response status:", response.status);
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.arrayBuffer();
          })
          .then(arrayBuffer => {
            console.log("Audio file loaded, size:", arrayBuffer.byteLength);
            return audioContext.decodeAudioData(arrayBuffer);
          })
          .then(audioBuffer => {
            console.log("Audio decoded successfully, duration:", audioBuffer.duration);
            
            // Add a small delay to ensure audio context is ready
            setTimeout(() => {
              const source = audioContext.createBufferSource();
              const gainNode = audioContext.createGain();

              source.buffer = audioBuffer;
              source.connect(gainNode);
              gainNode.connect(audioContext.destination);

              // Set volume and add fade-in effect
              gainNode.gain.setValueAtTime(0, audioContext.currentTime);
              gainNode.gain.linearRampToValueAtTime(
                0.5 * masterVolume,
                audioContext.currentTime + 0.1
              );

              source.start();
              console.log("MP3 sound started playing with delay");
            }, 100);
          })
          .catch(error => {
            console.error("Error loading audio file:", error);
            // Fallback to generated sound if MP3 fails to load
            console.log("Falling back to generated sound");
            // playSound(400, 0.4, "sine"); // Changed to lower frequency and sine wave
          });
      }

      // Handle window resize
      function handleResize() {
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
      }

      // Start new game
      function startGame() {
        // Resume audio context if suspended (required for user interaction)
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log("Audio context resumed");
          });
        }

        gameRunning = false; // Don't start immediately
        countdownActive = true;
        countdownValue = 3;
        score = 0;
        gameStartTime = Date.now();
        bird.y = CANVAS_HEIGHT / 2;
        bird.velocity = 0;
        pipes = [];
        pipeSpawnTimer = 0;
        bird.specialEffects = [];

        document.getElementById("score").textContent = "0";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("countdownOverlay").style.display = "block";

        // Start countdown
        startCountdown();
      }

      // Start countdown sequence
      function startCountdown() {
        updateCountdownDisplay();

        // Start countdown render loop
        const countdownRenderLoop = () => {
          if (countdownActive) {
            renderCountdown();
            requestAnimationFrame(countdownRenderLoop);
          }
        };
        countdownRenderLoop();

        const countdownInterval = setInterval(() => {
          countdownValue--;
          updateCountdownDisplay();

          if (countdownValue <= 0) {
            clearInterval(countdownInterval);
            endCountdown();
          }
        }, 1000);
      }

      // Update countdown display
      function updateCountdownDisplay() {
        const countdownNumber = document.getElementById("countdownNumber");
        const countdownText = document.querySelector(".countdown-text");

        if (countdownValue > 0) {
          countdownNumber.textContent = countdownValue;
          countdownText.textContent = "Get Ready!";

          // Play countdown sound
          // playSound(800 + countdownValue * 100, 0.2, "sine");
        } else {
          countdownNumber.textContent = "GO!";
          countdownText.textContent = "Start Flying!";

          // Play go sound
          playMP3Sound("assets/sounds/8bit1.mp3");
        }
      }

      // End countdown and start game
      function endCountdown() {
        countdownActive = false;
        gameRunning = true;

        // Hide countdown overlay
        setTimeout(() => {
          document.getElementById("countdownOverlay").style.display = "none";
        }, 1000);

        // Start the actual game
        gameLoop();
      }

      // Restart game
      function restartGame() {
        // Hide game over screen
        document.getElementById("gameOver").style.display = "none";

        // Start new game with countdown
        startGame();
      }

      // Go home function
      function goHome() {
        // Check if we're in a subdirectory and go up, or go to index.html
        if (window.location.pathname.includes("/")) {
          window.location.href = "../index.html";
        } else {
          window.location.href = "index.html";
        }
      }

      // Handle keyboard input
      function handleKeyDown(e) {
        if (e.code === "Space" && gameRunning) {
          e.preventDefault();
          flap();
        }
      }

      // Handle mouse click
      function handleClick() {
        if (gameRunning) {
          flap();
        }
      }

      // Make bird flap
      function flap() {
        bird.velocity = FLAP_SPEED;

        // Play flap sound
        // playSound(600, 0.1, "triangle");

        // Add special effects based on character
        addSpecialEffects();
      }

      // Add special effects based on character
      function addSpecialEffects() {
        switch (bird.character) {
          case "rainbow":
            bird.specialEffects.push({
              type: "rainbow",
              x: bird.x,
              y: bird.y,
              life: 30,
            });
            break;
          case "ninja":
            bird.specialEffects.push({
              type: "stealth",
              x: bird.x,
              y: bird.y,
              life: 20,
            });
            break;
        }
      }

      // Update bird physics
      function updateBird(deltaTime) {
        bird.velocity += GRAVITY;
        bird.y += bird.velocity;

        // Check boundaries
        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = 0;
        }
        if (bird.y > CANVAS_HEIGHT - bird.size) {
          gameOver();
        }

        // Update special effects
        bird.specialEffects = bird.specialEffects.filter((effect) => {
          effect.life--;
          return effect.life > 0;
        });
      }

      // Update pipes
      function updatePipes(deltaTime) {
        // Spawn new pipes
        pipeSpawnTimer += deltaTime;
        if (pipeSpawnTimer > PIPE_SPAWN_RATE) {
          spawnPipe();
          pipeSpawnTimer = 0;
        }

        // Move pipes and check collisions
        for (let i = pipes.length - 1; i >= 0; i--) {
          const pipe = pipes[i];
          pipe.x -= PIPE_SPEED;

          // Remove off-screen pipes
          if (pipe.x + PIPE_WIDTH < 0) {
            pipes.splice(i, 1);
            continue;
          }

          // Check collision with bird
          if (checkCollision(bird, pipe)) {
            gameOver();
            return;
          }

          // Score point when passing pipe
          if (!pipe.passed && pipe.x + PIPE_WIDTH < bird.x) {
            pipe.passed = true;
            score++;

            // Character bonus effects
            if (bird.character === "golden") {
              score++; // Double points
            }

            document.getElementById("score").textContent = score;

            // Play score sound
            // playSound(1000 + score * 50, 0.1);

            // Check achievements
            checkAchievements();
          }
        }
      }

      // Spawn new pipe
      function spawnPipe() {
        const gapY = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 100) + 50;
        pipes.push({
          x: CANVAS_WIDTH,
          gapY: gapY,
          passed: false,
        });
      }

      // Check collision between bird and pipe
      function checkCollision(bird, pipe) {
        // Adjust collision based on character size
        let effectiveSize = bird.size;
        if (bird.character === "mini") effectiveSize *= 0.6;
        if (bird.character === "giant") effectiveSize *= 1.5;

        return (
          bird.x + effectiveSize > pipe.x &&
          bird.x < pipe.x + PIPE_WIDTH &&
          (bird.y < pipe.gapY || bird.y + effectiveSize > pipe.gapY + PIPE_GAP)
        );
      }

      // Check achievements
      function checkAchievements() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        // Score achievements
        if (score >= 10 && !unlocked.has("score_10")) {
          unlockAchievement("score_10", "Getting Started");
          unlockCharacter("blue");
        }
        if (score >= 25 && !unlocked.has("score_25")) {
          unlockAchievement("score_25", "Rising Star");
          unlockCharacter("purple");
          unlockBackground("winter");
        }
        if (score >= 50 && !unlocked.has("score_50")) {
          unlockAchievement("score_50", "Bird Master");
          unlockBackground("galaxy");
        }
        if (score >= 75 && !unlocked.has("score_75")) {
          unlockAchievement("score_75", "Advanced Player");
          unlockBackground("autumn");
        }
        if (score >= 100 && !unlocked.has("score_100")) {
          unlockAchievement("score_100", "Legendary Bird");
          unlockBackground("space");
          unlockCharacter("golden");
        }
        if (score >= 150 && !unlocked.has("score_150")) {
          unlockAchievement("score_150", "Master Flier");
          unlockBackground("space");
        }
        if (score >= 200 && !unlocked.has("score_200")) {
          unlockAchievement("score_200", "Ultimate Legend");
          unlockBackground("space");
        }

        // Check for first game achievement
        if (stats.gamesPlayed === 1 && !unlocked.has("first_flight")) {
          unlockAchievement("first_flight", "First Flight");
          unlockCharacter("blue");
        }
      }

      // Unlock achievement
      function unlockAchievement(id, title) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlocked) progress.unlocked = [];
        if (!progress.unlocked.includes(id)) {
          progress.unlocked.push(id);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));

          // Show achievement notification
          showAchievementNotification(title);

          // Play achievement sound
          // playSound(1200, 0.3, "sawtooth");

          console.log(`Achievement unlocked: ${title}`);
        }
      }

      // Unlock character
      function unlockCharacter(characterId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedCharacters.includes(characterId)) {
          progress.unlockedCharacters.push(characterId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Character unlocked: ${characterId}`);
        }
      }

      // Unlock background
      function unlockBackground(backgroundId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        if (!progress.unlockedBackgrounds.includes(backgroundId)) {
          progress.unlockedBackgrounds.push(backgroundId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Background unlocked: ${backgroundId}`);
        }
      }

      // Show achievement notification
      function showAchievementNotification(title) {
        const notification = document.createElement("div");
        notification.className =
          "fixed top-20 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-3 rounded-full font-bold z-50 animate-bounce";
        notification.textContent = `ðŸ† ${title} Unlocked!`;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      // Game over
      function gameOver() {
        gameRunning = false;

        // Calculate game statistics
        const gameDuration = Date.now() - gameStartTime;
        const distance = score * 100; // Rough distance calculation

        // Update high score
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("flappyBirdHighScore", highScore);
        }

        // Save game statistics
        saveGameStats(score, gameDuration, distance);

        // Play game over sound
        // playSound(200, 0.5, "sawtooth");

        document.getElementById("finalScore").textContent = score;
        document.getElementById("gameOver").style.display = "block";
      }

      // Save game statistics
      function saveGameStats(score, duration, distance) {
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
        stats.highScore = Math.max(stats.highScore || 0, score);
        stats.totalScore = (stats.totalScore || 0) + score;
        stats.totalTime = (stats.totalTime || 0) + duration;
        stats.totalDistance = (stats.totalDistance || 0) + distance;

        // Track consecutive days
        const today = new Date().toDateString();
        if (!stats.lastPlayed) {
          stats.lastPlayed = today;
          stats.consecutiveDays = 1;
        } else if (stats.lastPlayed !== today) {
          const lastPlayed = new Date(stats.lastPlayed);
          const currentDate = new Date(today);
          const diffTime = currentDate - lastPlayed;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          if (diffDays === 1) {
            stats.consecutiveDays = (stats.consecutiveDays || 0) + 1;
          } else {
            stats.consecutiveDays = 1;
          }
          stats.lastPlayed = today;
        }

        // Track perfect runs (no pipe hits)
        if (score > 0) {
          stats.perfectRuns = (stats.perfectRuns || 0) + 1;
        }

        if (!stats.recentGames) stats.recentGames = [];
        if (!stats.scoreHistory) stats.scoreHistory = [];

        stats.recentGames.unshift({
          score,
          duration,
          distance,
          timestamp: Date.now(),
          character: bird.character,
        });

        stats.scoreHistory.push(score);

        // Keep only last 50 games
        if (stats.recentGames.length > 50) {
          stats.recentGames = stats.recentGames.slice(0, 50);
        }

        localStorage.setItem("flappyBirdStats", JSON.stringify(stats));

        // Check for achievements based on new stats
        checkAchievementsAfterGame(stats);
      }

      // Check achievements after game ends
      function checkAchievementsAfterGame(stats) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);

        // Games played achievements
        if (stats.gamesPlayed >= 10 && !unlocked.has("games_10")) {
          unlockAchievement("games_10", "Dedicated Player");
          unlockBackground("ocean");
        }
        if (stats.gamesPlayed >= 25 && !unlocked.has("games_25")) {
          unlockAchievement("games_25", "Regular Player");
          unlockBackground("forest");
        }
        if (stats.gamesPlayed >= 50 && !unlocked.has("games_50")) {
          unlockAchievement("games_50", "Veteran Player");
          unlockBackground("mountain");
        }
        if (stats.gamesPlayed >= 100 && !unlocked.has("games_100")) {
          unlockAchievement("games_100", "Ultimate Player");
          unlockBackground("city");
        }

        // Perfect runs achievements
        if (stats.perfectRuns >= 5 && !unlocked.has("perfect_5")) {
          unlockAchievement("perfect_5", "Perfect Player");
          unlockBackground("city");
          unlockCharacter("ninja");
        }
        if (stats.perfectRuns >= 10 && !unlocked.has("perfect_10")) {
          unlockAchievement("perfect_10", "Perfect Master");
          unlockCharacter("ninja");
        }

        // Consecutive days achievements
        if (stats.consecutiveDays >= 7 && !unlocked.has("daily_player")) {
          unlockAchievement("daily_player", "Daily Player");
          unlockBackground("rainbow");
          unlockCharacter("rainbow");
        }

        // Distance achievements
        if (stats.totalDistance >= 10000 && !unlocked.has("distance_10k")) {
          unlockAchievement("distance_10k", "Long Distance Flier");
          unlockBackground("desert");
        }
      }

      // Render functions
      function renderBird() {
        // Clear any previous rendering artifacts
        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        // Apply character-specific modifications
        let effectiveSize = bird.size;
        let effectiveColor = bird.color;

        switch (bird.character) {
          case "blue":
            effectiveColor = "#3B82F6";
            effectiveSize *= 0.9;
            break;
          case "purple":
            effectiveColor = "#8B5CF6";
            effectiveSize *= 0.8;
            break;
          case "mini":
            effectiveSize *= 0.6;
            break;
          case "giant":
            effectiveSize *= 1.5;
            break;
        }

        // Draw bird
        ctx.fillStyle = effectiveColor;
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize / 2,
          bird.y + effectiveSize / 2,
          effectiveSize / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Bird eye
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize * 0.7,
          bird.y + effectiveSize * 0.3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Bird wing
        ctx.fillStyle = "#FFA500";
        ctx.beginPath();
        ctx.ellipse(
          bird.x + effectiveSize * 0.3,
          bird.y + effectiveSize * 0.5,
          8,
          4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Render special effects
        renderSpecialEffects();

        ctx.restore();
      }

      // Render special effects
      function renderSpecialEffects() {
        bird.specialEffects.forEach((effect) => {
          switch (effect.type) {
            case "rainbow":
              ctx.strokeStyle = `hsl(${(Date.now() * 0.1) % 360}, 100%, 50%)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
              ctx.stroke();
              break;
            case "stealth":
              ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 40, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
        });
      }

      function renderPipes() {
        ctx.fillStyle = "#228B22";

        pipes.forEach((pipe) => {
          // Top pipe
          ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.gapY);

          // Bottom pipe
          ctx.fillRect(
            pipe.x,
            pipe.gapY + PIPE_GAP,
            PIPE_WIDTH,
            CANVAS_HEIGHT - pipe.gapY - PIPE_GAP
          );

          // Pipe caps
          ctx.fillStyle = "#006400";
          ctx.fillRect(pipe.x - 5, pipe.gapY - 20, PIPE_WIDTH + 10, 20);
          ctx.fillRect(pipe.x - 5, pipe.gapY + PIPE_GAP, PIPE_WIDTH + 10, 20);
          ctx.fillStyle = "#228B22";
        });
      }

      function renderBackground() {
        // Load selected background
        const selectedBackground =
          localStorage.getItem("flappyBirdBackground") || "default";
        const backgroundImage = new Image();
        backgroundImage.src = `assets/images/${selectedBackground}.jpg`;

        // Draw clouds
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        for (let i = 0; i < 5; i++) {
          const x = ((Date.now() * 0.02 + i * 200) % (CANVAS_WIDTH + 100)) - 50;
          const y = 50 + i * 80;
          drawCloud(x, y, 60 + i * 10);
        }
      }

      function drawCloud(x, y, size) {
        ctx.beginPath();
        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.4, y, size * 0.6, 0, Math.PI * 2);
        ctx.arc(x + size * 0.8, y, size * 0.4, 0, Math.PI * 2);
        ctx.arc(x + size * 0.6, y + size * 0.2, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.2, y + size * 0.1, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Main game loop
      function gameLoop(currentTime = 0) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        // Update game state
        updateBird(deltaTime);
        updatePipes(deltaTime);

        // Clear canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Additional clearing to prevent artifacts
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        // Render everything
        renderBackground();
        renderPipes();
        renderBird();

        // Continue loop
        requestAnimationFrame(gameLoop);
      }

      // Render bird during countdown (static position)
      function renderBirdStatic() {
        // Apply character-specific modifications
        let effectiveSize = bird.size;
        let effectiveColor = bird.color;

        switch (bird.character) {
          case "blue":
            effectiveColor = "#3B82F6";
            effectiveSize *= 0.9;
            break;
          case "purple":
            effectiveColor = "#8B5CF6";
            effectiveSize *= 0.8;
            break;
          case "mini":
            effectiveSize *= 0.6;
            break;
          case "giant":
            effectiveSize *= 1.5;
            break;
        }

        // Clear any previous rendering artifacts
        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        // Draw bird in static position
        ctx.fillStyle = effectiveColor;
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize / 2,
          bird.y + effectiveSize / 2,
          effectiveSize / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Bird eye
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.x + effectiveSize * 0.7,
          bird.y + effectiveSize * 0.3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Bird wing
        ctx.fillStyle = "#FFA500";
        ctx.beginPath();
        ctx.ellipse(
          bird.x + effectiveSize * 0.3,
          bird.y + effectiveSize * 0.5,
          8,
          4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.restore();
      }

      // Render countdown screen
      function renderCountdown() {
        // Clear canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Additional clearing to prevent artifacts
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        // Render background
        renderBackground();

        // Render bird in static position
        renderBirdStatic();

        // Render pipes (if any exist)
        renderPipes();
      }

      // Start the game when page loads
      window.addEventListener("load", init);
    </script>
  </body>
</html>
