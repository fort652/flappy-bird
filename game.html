<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flappy Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      canvas {
        display: block;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }

      .game-over {
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.85));
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        animation: gameOverSlideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        max-width: 90vw;
        width: 400px;
      }

      @keyframes gameOverSlideIn {
        0% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 0;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.05);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .game-over h2 {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 3rem;
        font-weight: 900;
        text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        margin-bottom: 1rem;
        animation: titlePulse 2s ease-in-out infinite;
      }

      @keyframes titlePulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .final-score {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 2rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .score-number {
        background: linear-gradient(135deg, #10b981, #059669);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-weight: 900;
        font-size: 2rem;
      }

      .game-over-buttons {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
      }

      .game-over-button {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        border: none;
        border-radius: 1rem;
        padding: 1rem 2rem;
        font-size: 1.1rem;
        font-weight: 700;
        color: #000;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        box-shadow: 0 8px 25px rgba(251, 191, 36, 0.4);
      }

      .game-over-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        transform: translateX(-100%);
        transition: transform 0.6s ease;
      }

      .game-over-button:hover::before {
        transform: translateX(100%);
      }

      .game-over-button:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 15px 35px rgba(251, 191, 36, 0.6);
      }

      .game-over-button:active {
        transform: translateY(-1px) scale(0.98);
      }

      .button-content {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
      }

      .button-icon {
        width: 1.5rem;
        height: 1.5rem;
        object-fit: contain;
      }

      .stats-summary {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(147, 51, 234, 0.15));
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 1rem;
        padding: 1rem;
        margin-bottom: 1.5rem;
        backdrop-filter: blur(10px);
      }

      .stats-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .stats-row:last-child {
        margin-bottom: 0;
      }

      .stats-label {
        color: #cbd5e1;
        font-size: 0.9rem;
      }

      .stats-value {
        color: #fbbf24;
        font-weight: 700;
        font-size: 1rem;
      }

      .countdown-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        pointer-events: none;
      }

      .countdown-number {
        font-size: 120px;
        font-weight: bold;
        color: #fbbf24;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
        animation: countdownPulse 0.5s ease-out;
      }

      .countdown-text {
        font-size: 32px;
        color: white;
        margin-top: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      @keyframes countdownPulse {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes lightningPulse {
        0%, 100% {
          transform: scale(1);
          filter: brightness(1);
        }
        50% {
          transform: scale(1.1);
          filter: brightness(1.3);
        }
      }

      @keyframes lightningBolt {
        0% {
          transform: scale(1) rotate(0deg);
        }
        25% {
          transform: scale(1.2) rotate(5deg);
        }
        50% {
          transform: scale(1.1) rotate(-3deg);
        }
        75% {
          transform: scale(1.15) rotate(2deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }

      .lightning-icon {
        animation: lightningPulse 2s ease-in-out infinite, lightningBolt 3s ease-in-out infinite;
      }

      .lightning-icon.active {
        animation: lightningBolt 0.5s ease-in-out infinite;
      }

      canvas {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        outline: none;
      }

      * {
        -webkit-tap-highlight-color: transparent;
      }

      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      #gameCanvas {
        display: block;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }
    </style>
  </head>
  <body
    class="m-0 p-0 font-sans bg-gradient-to-br from-sky-300 to-green-200 flex justify-center items-center min-h-screen overflow-hidden"
    style="height: 100vh; min-height: 100vh;"
  >
    <div class="relative rounded-3xl shadow-2xl overflow-hidden w-full h-full">
      <canvas id="gameCanvas" class="w-full h-full"></canvas>

      <div
        class="absolute inset-0 pointer-events-none flex flex-col justify-between p-5"
      >
        <div
          class="text-center text-5xl font-bold text-white drop-shadow-lg mt-5"
          id="score"
        >
          0
        </div>
      </div>
      
      <!-- Special Ability Button -->
      <div class="absolute top-5 left-5 z-10">
        <button
          id="specialAbilityBtn"
          class="bg-gradient-to-br from-yellow-400 to-orange-500 w-16 h-16 rounded-full shadow-lg border-2 border-yellow-300 hover:from-yellow-300 hover:to-orange-400 transition-all duration-200 transform hover:scale-110 active:scale-95"
          onclick="activateSpecialAbility()"
        >
          <div class="flex items-center justify-center w-full h-full">
            <svg id="lightningIcon" class="w-8 h-8 text-white lightning-icon" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd"></path>
            </svg>
          </div>
        </button>
        
        <!-- Cooldown Overlay -->
        <div id="cooldownOverlay" class="absolute inset-0 bg-black bg-opacity-50 rounded-full hidden">
          <div class="flex items-center justify-center w-full h-full">
            <span id="cooldownText" class="text-white text-xs font-bold"></span>
          </div>
        </div>
      </div>

      <!-- Special Ability Indicator -->
      <div class="absolute top-5 right-5 text-white text-sm">
        <div class="bg-black bg-opacity-50 rounded-lg p-3">
          <div class="text-yellow-400 font-bold mb-1">Special Ability</div>
          <div id="abilityStatus" class="text-xs mb-2">Tap lightning bolt to activate</div>
          <div id="abilityCooldown" class="text-xs text-gray-300"></div>
        </div>
      </div>
      
      <!-- Debug Info (only visible in development) -->
      <div class="absolute bottom-5 left-5 text-white text-xs bg-black bg-opacity-50 rounded-lg p-2 hidden" id="debugInfo">
        <div>Character: <span id="debugCharacter">-</span></div>
        <div>Images: <span id="debugImages">-</span></div>
        <div>Game State: <span id="debugGameState">-</span></div>
      </div>

      <div
        class="countdown-overlay"
        id="countdownOverlay"
        style="display: none"
      >
        <div class="countdown-number" id="countdownNumber">3</div>
        <div class="countdown-text">Get Ready!</div>
      </div>

      <div
        class="game-over flex flex-col items-center justify-center gap-6 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white p-8 rounded-2xl text-center hidden"
        id="gameOver"
      >
        <h2 class="text-3xl mb-3 text-red-400">Game Over!</h2>
        
        <div class="final-score">
          Final Score: <span class="score-number" id="finalScore">0</span>
        </div>

        <div class="stats-summary">
          <div class="stats-row">
            <span class="stats-label">High Score:</span>
            <span class="stats-value" id="highScoreDisplay">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Games Played:</span>
            <span class="stats-value" id="gamesPlayedDisplay">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Character:</span>
            <span class="stats-value" id="characterDisplay">Default</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Special Ability:</span>
            <span class="stats-value text-xs" id="gameOverAbilityText">Tap lightning bolt button</span>
          </div>
        </div>

        <div class="game-over-buttons">
          <button 
            onclick="restartGame()" 
            class="game-over-button"
          >
            <div class="button-content">
              <img src="assets/images/buttons/reload.png" alt="Restart" class="button-icon">
              Play Again
            </div>
          </button>
          
          <button 
            onclick="goHome()" 
            class="game-over-button"
          >
            <div class="button-content">
              <img src="assets/images/buttons/back.png" alt="Home" class="button-icon">
              Go Home
            </div>
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      // No longer needed since we're using custom buttons
    </script>

    <script>
      let CANVAS_WIDTH, CANVAS_HEIGHT;
      const GRAVITY = 0.6;
      const FLAP_SPEED = -8;
      const PIPE_WIDTH = 80;
      const PIPE_GAP = 200;
      const PIPE_SPEED = 2;
      const PIPE_SPAWN_RATE = 2000;

      // Game state
      let canvas, ctx;
      let gameRunning = false;
      let countdownActive = false;
      let countdownValue = 3;
      let score = 0;
      let highScore = localStorage.getItem("flappyBirdHighScore") || 0;
      let gameStartTime = 0;
      let specialAbilityActive = false;
      let specialAbilityCooldown = 0;
      let specialAbilityDuration = 0;

      const bird = {
        x: 150,
        y: CANVAS_HEIGHT / 2,
        velocity: 0,
        size: 20,
        color: "#FFD700",
        character: "default",
        specialEffects: [],
      };

      let pipes = [];

      let lastTime = 0;
      let pipeSpawnTimer = 0;

      let audioContext;
      let masterVolume = 0.8;
      let soundEffects = true;
      let currentAudioSource = null; // Track current playing audio
      let gameStartAudioSource = null; // Track the game start audio
      let characterImages = {}; // Cache for character images

      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        // Set canvas to full viewport dimensions
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        loadGameSettings();
        loadGameProgress();
        repairProgressData();

        initAudio();
        preloadCharacterImages();

        document.addEventListener("keydown", handleKeyDown);
        canvas.addEventListener("click", handleClick);
        canvas.addEventListener("touchstart", handleTouch);
        window.addEventListener("resize", handleResize);

        // Wait a bit for character images to load before starting the game
        setTimeout(() => {
          startGame();
        }, 500);
      }

      function loadGameSettings() {
        const saved = localStorage.getItem("flappyBirdSettings");
        if (saved) {
          const settings = JSON.parse(saved);
          masterVolume = settings.masterVolume / 100;
          soundEffects = settings.soundEffects;
        }
      }

      function loadGameProgress() {
        // First, ensure default unlocks are available
        ensureDefaultUnlocks();
        
        // Load character from localStorage (this is what the characters page saves to)
        const savedCharacter = localStorage.getItem("flappyBirdCharacter");
        if (savedCharacter) {
          bird.character = savedCharacter;
          console.log(`Loaded saved character: ${savedCharacter}`);
        } else {
          // If no character is saved, use default
          bird.character = "default";
          console.log(`No character saved, using default: ${bird.character}`);
          // Save the default character to localStorage
          localStorage.setItem("flappyBirdCharacter", "default");
        }

        // Also update the progress system to keep it in sync
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        progress.currentCharacter = bird.character;
        localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
        
        console.log(`Final bird character set to: ${bird.character}`);
        
        // Force a refresh of the character display after loading
        setTimeout(() => {
          updateCharacterDisplay();
        }, 100);
      }

      function ensureDefaultUnlocks() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        
        // Initialize arrays if they don't exist
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        
        // Always ensure default character is unlocked
        if (!progress.unlockedCharacters.includes("default")) {
          progress.unlockedCharacters.push("default");
        }
        
        // Always ensure default background is unlocked
        if (!progress.unlockedBackgrounds.includes("default")) {
          progress.unlockedBackgrounds.push("default");
        }
        
        // Save the updated progress
        localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
      }

      function repairProgressData() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        
        // Ensure all arrays exist
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        if (!progress.unlocked) progress.unlocked = [];
        
        // Check for any missing default unlocks
        const defaultCharacters = ["default"];
        const defaultBackgrounds = ["default"];
        
        // Add any missing default characters
        defaultCharacters.forEach(char => {
          if (!progress.unlockedCharacters.includes(char)) {
            progress.unlockedCharacters.push(char);
            console.log(`Restored default character: ${char}`);
          }
        });
        
        // Add any missing default backgrounds
        defaultBackgrounds.forEach(bg => {
          if (!progress.unlockedBackgrounds.includes(bg)) {
            progress.unlockedBackgrounds.push(bg);
            console.log(`Restored default background: ${bg}`);
          }
        });
        
        // Save the repaired progress
        localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
        console.log("Progress data repaired:", progress);
      }

      // Debug function - can be called from browser console
      function debugProgress() {
        const progress = localStorage.getItem("flappyBirdProgress");
        const character = localStorage.getItem("flappyBirdCharacter");
        const background = localStorage.getItem("flappyBirdBackground");
        
        console.log("=== PROGRESS DEBUG ===");
        console.log("Progress data:", progress ? JSON.parse(progress) : "None");
        console.log("Selected character:", character);
        console.log("Selected background:", background);
        
        if (progress) {
          const p = JSON.parse(progress);
          console.log("Unlocked characters:", p.unlockedCharacters || []);
          console.log("Unlocked backgrounds:", p.unlockedBackgrounds || []);
          console.log("Unlocked achievements:", p.unlocked || []);
        }
        
        // Try to repair any issues
        repairProgressData();
        
        console.log("=== END DEBUG ===");
      }

      // Test function for special abilities
      function testSpecialAbility() {
        console.log("=== TESTING SPECIAL ABILITY ===");
        console.log("Button element:", document.getElementById("specialAbilityBtn"));
        console.log("Button disabled:", document.getElementById("specialAbilityBtn")?.disabled);
        console.log("Current character:", bird.character);
        console.log("Game running:", gameRunning);
        console.log("Special ability active:", specialAbilityActive);
        console.log("Cooldown:", specialAbilityCooldown);
        console.log("=== END TEST ===");
      }

      // Make test functions available globally for debugging
      window.testSpecialAbility = testSpecialAbility;
      window.debugProgress = debugProgress;
      window.debugCharacter = () => {
        console.log("=== CHARACTER DEBUG ===");
        console.log("Bird character:", bird.character);
        console.log("Character images loaded:", Object.keys(characterImages));
        console.log("Selected character from localStorage:", localStorage.getItem("flappyBirdCharacter"));
        console.log("Character image object:", characterImages[bird.character]);
        console.log("=== END CHARACTER DEBUG ===");
      };
      
      window.reloadCharacter = () => {
        console.log("Reloading character...");
        const savedCharacter = localStorage.getItem("flappyBirdCharacter");
        if (savedCharacter) {
          bird.character = savedCharacter;
          console.log(`Character reloaded to: ${bird.character}`);
          updateCharacterDisplay();
        } else {
          console.log("No character saved in localStorage");
        }
      };
      
      window.forceCharacterReload = () => {
        console.log("Force reloading character images...");
        characterImages = {}; // Clear cache
        preloadCharacterImages(); // Reload all images
      };
      
      window.switchCharacter = (characterId) => {
        console.log(`Switching character to: ${characterId}`);
        bird.character = characterId;
        localStorage.setItem("flappyBirdCharacter", characterId);
        updateCharacterDisplay();
        updateAbilityUI();
      };

      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        } catch (e) {
          console.log("Audio not supported");
        }
      }

      function preloadCharacterImages() {
        console.log("Starting to preload character images...");
        
        const characters = [
          { id: "default", path: "assets/images/characters/tweety.png" },
          { id: "blue", path: "assets/images/characters/blue-bird.png" },
          { id: "purple", path: "assets/images/characters/purple-bird.png" },
          { id: "golden", path: "assets/images/characters/tweety.png" }, // Using tweety as placeholder
          { id: "rainbow", path: "assets/images/characters/tweety.png" }, // Using tweety as placeholder
          { id: "ninja", path: "assets/images/characters/tweety.png" }, // Using tweety as placeholder
          { id: "giant", path: "assets/images/characters/tweety.png" }, // Using tweety as placeholder
          { id: "mini", path: "assets/images/characters/tweety.png" } // Using tweety as placeholder
        ];

        let loadedCount = 0;
        const totalCount = characters.length;

        characters.forEach(char => {
          const img = new Image();
          img.onload = () => {
            characterImages[char.id] = img;
            loadedCount++;
            console.log(`Character image loaded: ${char.id} (${loadedCount}/${totalCount})`);
            
            // Update character display when images are loaded
            if (char.id === bird.character) {
              updateCharacterDisplay();
            }
            
            // Check if all images are loaded
            if (loadedCount === totalCount) {
              console.log("All character images loaded successfully!");
              updateCharacterDisplay();
            }
          };
          img.onerror = () => {
            console.log(`Failed to load character image: ${char.path}`);
            // Try alternative path if the characters subfolder doesn't exist
            const altImg = new Image();
            altImg.onload = () => {
              characterImages[char.id] = altImg;
              loadedCount++;
              console.log(`Character image loaded from alternative path: ${char.id} (${loadedCount}/${totalCount})`);
              if (char.id === bird.character) {
                updateCharacterDisplay();
              }
              if (loadedCount === totalCount) {
                console.log("All character images loaded successfully!");
                updateCharacterDisplay();
              }
            };
            altImg.onerror = () => {
              console.log(`Failed to load character image from alternative path: ${char.id}`);
              loadedCount++;
              if (loadedCount === totalCount) {
                console.log("All character images processed (some failed)");
                updateCharacterDisplay();
              }
            };
            // Try without the characters subfolder
            altImg.src = char.path.replace('characters/', '');
          };
          img.src = char.path;
        });
      }

      function playMP3Sound(audioPath, onSourceCreated = null) {
        if (!soundEffects || !audioContext) {
          return null;
        }

        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        // Stop any currently playing audio before starting new one
        stopCurrentAudio();

        fetch(audioPath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.arrayBuffer();
          })
          .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
          .then(audioBuffer => {
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = audioBuffer;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(
              0.5 * masterVolume,
              audioContext.currentTime + 0.1
            );

            source.start();
            
            // Store the audio source for potential stopping
            currentAudioSource = source;
            
            // Call the callback if provided
            if (onSourceCreated) {
              onSourceCreated(source);
            }
          })
          .catch(error => {
            // Audio loading failed, continue without sound
          });
      }

      function stopCurrentAudio() {
        if (currentAudioSource) {
          try {
            currentAudioSource.stop();
            currentAudioSource = null;
          } catch (error) {
            currentAudioSource = null;
          }
        }
      }

      function stopGameStartAudio() {
        if (gameStartAudioSource) {
          try {
            gameStartAudioSource.stop();
            gameStartAudioSource = null;
          } catch (error) {
            gameStartAudioSource = null;
          }
        }
      }

      function stopAllAudio() {
        stopCurrentAudio();
        stopGameStartAudio();
      }

      function handleResize() {
        // Update canvas dimensions on window resize
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
      }

      function startGame() {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }

        // Stop any currently playing audio when starting a new game
        stopAllAudio();

        // Reload character from localStorage to ensure it's current
        const savedCharacter = localStorage.getItem("flappyBirdCharacter");
        if (savedCharacter && savedCharacter !== bird.character) {
          bird.character = savedCharacter;
          console.log(`Character updated to: ${bird.character}`);
        }

        gameRunning = false;
        countdownActive = true;
        countdownValue = 3;
        score = 0;
        gameStartTime = Date.now();
        bird.y = CANVAS_HEIGHT / 2;
        bird.velocity = 0;
        pipes = [];
        pipeSpawnTimer = 0;
        bird.specialEffects = [];
        
        // Reset special ability system
        specialAbilityActive = false;
        specialAbilityCooldown = 0;
        specialAbilityDuration = 0;

        document.getElementById("score").textContent = "0";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("countdownOverlay").style.display = "block";
        
        // Update ability UI to show ready state
        updateAbilityUI();
        
        // Update character display
        updateCharacterDisplay();

        startCountdown();
      }

      function startCountdown() {
        updateCountdownDisplay();

        const countdownRenderLoop = () => {
          if (countdownActive) {
            renderCountdown();
            requestAnimationFrame(countdownRenderLoop);
          }
        };
        countdownRenderLoop();

        const countdownInterval = setInterval(() => {
          countdownValue--;
          updateCountdownDisplay();

          if (countdownValue <= 0) {
            clearInterval(countdownInterval);
            endCountdown();
          }
        }, 1000);
      }

      function updateCountdownDisplay() {
        const countdownNumber = document.getElementById("countdownNumber");
        const countdownText = document.querySelector(".countdown-text");

        if (countdownValue > 0) {
          countdownNumber.textContent = countdownValue;
          countdownText.textContent = "Get Ready!";
        } else {
          countdownNumber.textContent = "GO!";
          countdownText.textContent = "Start Flying!";

          // Play game start sound and track the source
          playMP3Sound("assets/sounds/8bit1.mp3", (source) => {
            gameStartAudioSource = source;
          });
        }
      }

      function endCountdown() {
        countdownActive = false;
        gameRunning = true;

        // Stop the game start audio when the game actually starts
        stopGameStartAudio();

        setTimeout(() => {
          document.getElementById("countdownOverlay").style.display = "none";
        }, 1000);
        
        // Update ability UI when game starts
        updateAbilityUI();

        gameLoop();
      }

      function restartGame() {
        document.getElementById("gameOver").style.display = "none";

        // Stop any current audio before restarting
        stopCurrentAudio();

        startGame();
      }

      function goHome() {
        // Stop any current audio when leaving the game
        stopCurrentAudio();
        stopGameStartAudio();

        if (window.location.pathname.includes("/")) {
          window.location.href = "../index.html";
        } else {
          window.location.href = "index.html";
        }
      }

      function handleKeyDown(e) {
        if (e.code === "Space" && gameRunning) {
          e.preventDefault();
          flap();
        }
        
        // Debug toggle with F12 key
        if (e.code === "F12") {
          e.preventDefault();
          const debugInfo = document.getElementById("debugInfo");
          if (debugInfo) {
            debugInfo.classList.toggle("hidden");
          }
        }
      }

      function handleClick() {
        if (gameRunning) {
          flap();
        }
      }

      function handleTouch(e) {
        if (gameRunning) {
          e.preventDefault(); // Prevent default touch behavior
          flap();
        }
      }

      function flap() {
        bird.velocity = FLAP_SPEED;

        addSpecialEffects();
      }

      function addSpecialEffects() {
        switch (bird.character) {
          case "rainbow":
            bird.specialEffects.push({
              type: "rainbow",
              x: bird.x,
              y: bird.y,
              life: 30,
              followBird: true, // This effect will follow the bird
            });
            break;
          case "ninja":
            bird.specialEffects.push({
              type: "stealth",
              x: bird.x,
              y: bird.y,
              life: 20,
              followBird: true, // This effect will follow the bird
            });
            break;
        }
      }

      // Special ability system
      function activateSpecialAbility() {
        console.log("activateSpecialAbility called!");
        console.log("Current character:", bird.character);
        console.log("Special ability active:", specialAbilityActive);
        console.log("Cooldown remaining:", specialAbilityCooldown);
        
        if (specialAbilityCooldown > 0 || specialAbilityActive) {
          console.log("Cannot activate - on cooldown or already active");
          return; // Can't activate if on cooldown or already active
        }

        console.log("Activating special ability for:", bird.character);

        switch (bird.character) {
          case "blue":
            activateSpeedBoost();
            break;
          case "purple":
            activateAgilityBoost();
            break;
          case "golden":
            activateDoublePoints();
            break;
          case "rainbow":
            activateRainbowTrail();
            break;
          case "ninja":
            activateStealthMode();
            break;
          case "giant":
            activateCrashThrough();
            break;
          case "mini":
            activateMiniMode();
            break;
          default:
            console.log("Default bird has no special ability");
            break;
        }
      }

      function activateSpeedBoost() {
        specialAbilityActive = true;
        specialAbilityDuration = 180; // 3 seconds at 60fps
        specialAbilityCooldown = 600; // 10 second cooldown
        
        // Visual effect that follows the bird
        bird.specialEffects.push({
          type: "speedBoost",
          x: bird.x,
          y: bird.y,
          life: 180,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Speed Boost activated!");
      }

      function activateAgilityBoost() {
        specialAbilityActive = true;
        specialAbilityDuration = 120; // 2 seconds
        specialAbilityCooldown = 480; // 8 second cooldown
        
        bird.specialEffects.push({
          type: "agilityBoost",
          x: bird.x,
          y: bird.y,
          life: 120,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Agility Boost activated!");
      }

      function activateDoublePoints() {
        specialAbilityActive = true;
        specialAbilityDuration = 300; // 5 seconds
        specialAbilityCooldown = 900; // 15 second cooldown
        
        bird.specialEffects.push({
          type: "doublePoints",
          x: bird.x,
          y: bird.y,
          life: 300,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Double Points activated!");
      }

      function activateRainbowTrail() {
        specialAbilityActive = true;
        specialAbilityDuration = 240; // 4 seconds
        specialAbilityCooldown = 720; // 12 second cooldown
        
        bird.specialEffects.push({
          type: "rainbowTrail",
          x: bird.x,
          y: bird.y,
          life: 240,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Rainbow Trail activated!");
      }

      function activateStealthMode() {
        specialAbilityActive = true;
        specialAbilityDuration = 180; // 3 seconds
        specialAbilityCooldown = 600; // 10 second cooldown
        
        bird.specialEffects.push({
          type: "stealth",
          x: bird.x,
          y: bird.y,
          life: 180,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Stealth Mode activated!");
      }

      function activateCrashThrough() {
        specialAbilityActive = true;
        specialAbilityDuration = 120; // 2 seconds
        specialAbilityCooldown = 600; // 10 second cooldown
        
        bird.specialEffects.push({
          type: "crashThrough",
          x: bird.x,
          y: bird.y,
          life: 120,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Crash Through activated!");
      }

      function activateMiniMode() {
        specialAbilityActive = true;
        specialAbilityDuration = 240; // 4 seconds
        specialAbilityCooldown = 720; // 12 second cooldown
        
        bird.specialEffects.push({
          type: "miniMode",
          x: bird.x,
          y: bird.y,
          life: 240,
          followBird: true, // This effect will follow the bird
        });
        
        console.log("Mini Mode activated!");
      }

      function updateSpecialAbilities() {
        // Update cooldown
        if (specialAbilityCooldown > 0) {
          specialAbilityCooldown--;
        }
        
        // Update duration
        if (specialAbilityDuration > 0) {
          specialAbilityDuration--;
          if (specialAbilityDuration <= 0) {
            specialAbilityActive = false;
            console.log("Special ability deactivated");
          }
        }
        
        // Update UI
        updateAbilityUI();
      }

      function updateCharacterDisplay() {
        console.log(`Updating character display for: ${bird.character}`);
        console.log(`Available character images:`, Object.keys(characterImages));
        
        // Check if the character image is loaded
        if (characterImages[bird.character]) {
          console.log(`Character image found for ${bird.character}`);
          
          // Show a brief notification that the character has loaded
          if (gameRunning || countdownActive) {
            showCharacterNotification(bird.character);
          }
        } else {
          console.log(`Character image NOT found for ${bird.character}`);
        }
        
        // Update debug info
        updateDebugInfo();
      }
      
      function updateDebugInfo() {
        const debugCharacter = document.getElementById("debugCharacter");
        const debugImages = document.getElementById("debugImages");
        const debugGameState = document.getElementById("debugGameState");
        
        if (debugCharacter) debugCharacter.textContent = bird.character;
        if (debugImages) debugImages.textContent = Object.keys(characterImages).join(", ");
        if (debugGameState) debugGameState.textContent = gameRunning ? "Running" : countdownActive ? "Countdown" : "Stopped";
      }
      
      function showCharacterNotification(characterName) {
        const notification = document.createElement("div");
        notification.className = "fixed top-32 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-full font-bold z-50 animate-bounce";
        
        const characterNames = {
          "default": "Default Bird",
          "blue": "Blue Bird",
          "purple": "Purple Bird",
          "golden": "Golden Bird",
          "rainbow": "Rainbow Bird",
          "ninja": "Ninja Bird",
          "giant": "Giant Bird",
          "mini": "Mini Bird"
        };
        
        notification.textContent = `🐦 ${characterNames[characterName] || characterName} Loaded!`;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 2000);
      }

      function updateAbilityUI() {
        const abilityStatus = document.getElementById("abilityStatus");
        const abilityCooldown = document.getElementById("abilityCooldown");
        const specialAbilityBtn = document.getElementById("specialAbilityBtn");
        const cooldownOverlay = document.getElementById("cooldownOverlay");
        const cooldownText = document.getElementById("cooldownText");
        const lightningIcon = document.getElementById("lightningIcon");
        
        if (!abilityStatus || !abilityCooldown || !specialAbilityBtn || !cooldownOverlay || !cooldownText || !lightningIcon) return;
        
        // Hide button for default bird (no special abilities)
        if (bird.character === "default") {
          specialAbilityBtn.style.display = "none";
          abilityStatus.textContent = "No special abilities";
          abilityStatus.className = "text-xs mb-2 text-gray-400";
          abilityCooldown.textContent = "";
          return;
        }
        
        // Show button for birds with special abilities
        specialAbilityBtn.style.display = "block";
        
        if (specialAbilityActive) {
          abilityStatus.textContent = "ACTIVE!";
          abilityStatus.className = "text-xs mb-2 text-green-400 font-bold";
          abilityCooldown.textContent = `Duration: ${Math.ceil(specialAbilityDuration / 60)}s`;
          
          // Disable button and show active state
          specialAbilityBtn.disabled = true;
          specialAbilityBtn.className = "bg-gradient-to-br from-green-400 to-green-600 w-16 h-16 rounded-full shadow-lg border-2 border-green-300 transition-all duration-200 transform scale-95";
          cooldownOverlay.classList.add("hidden");
          lightningIcon.classList.add("active");
        } else if (specialAbilityCooldown > 0) {
          abilityStatus.textContent = "On Cooldown";
          abilityStatus.className = "text-xs mb-2 text-red-400";
          abilityCooldown.textContent = `Ready in: ${Math.ceil(specialAbilityCooldown / 60)}s`;
          
          // Disable button and show cooldown
          specialAbilityBtn.disabled = true;
          specialAbilityBtn.className = "bg-gradient-to-br from-gray-400 to-gray-600 w-16 h-16 rounded-full shadow-lg border-2 border-gray-300 transition-all duration-200";
          cooldownOverlay.classList.remove("hidden");
          cooldownText.textContent = Math.ceil(specialAbilityCooldown / 60);
          lightningIcon.classList.remove("active");
        } else {
          abilityStatus.textContent = "Tap lightning bolt to activate";
          abilityStatus.className = "text-xs mb-2 text-white";
          abilityCooldown.textContent = "";
          
          // Enable button and show ready state
          specialAbilityBtn.disabled = false;
          specialAbilityBtn.className = "bg-gradient-to-br from-yellow-400 to-orange-500 w-16 h-16 rounded-full shadow-lg border-2 border-yellow-300 hover:from-yellow-300 hover:to-orange-400 transition-all duration-200 transform hover:scale-110 active:scale-95";
          cooldownOverlay.classList.add("hidden");
          lightningIcon.classList.remove("active");
        }
      }

      function updateBird(deltaTime) {
        // Apply special ability effects
        let effectiveGravity = GRAVITY;
        let effectiveFlapSpeed = FLAP_SPEED;
        let effectiveSize = bird.size;
        
        if (specialAbilityActive) {
          switch (bird.character) {
            case "blue":
              effectiveGravity *= 0.7; // Reduced gravity during speed boost
              break;
            case "purple":
              effectiveGravity *= 0.8; // Better control during agility boost
              break;
            case "mini":
              effectiveSize *= 0.4; // Even smaller during mini mode
              break;
            case "giant":
              effectiveSize *= 2.0; // Even larger during crash through
              break;
          }
        }
        
        bird.velocity += effectiveGravity;
        bird.y += bird.velocity;

        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = 0;
        }
        if (bird.y > CANVAS_HEIGHT - effectiveSize) {
          gameOver();
        }

        // Update special abilities
        updateSpecialAbilities();

        bird.specialEffects = bird.specialEffects.filter((effect) => {
          effect.life--;
          
          // Update position for effects that follow the bird
          if (effect.followBird) {
            effect.x = bird.x;
            effect.y = bird.y;
          }
          
          return effect.life > 0;
        });
      }

      function updatePipes(deltaTime) {
        pipeSpawnTimer += deltaTime;
        if (pipeSpawnTimer > PIPE_SPAWN_RATE) {
          spawnPipe();
          pipeSpawnTimer = 0;
        }

        for (let i = pipes.length - 1; i >= 0; i--) {
          const pipe = pipes[i];
          pipe.x -= PIPE_SPEED;

          if (pipe.x + PIPE_WIDTH < 0) {
            pipes.splice(i, 1);
            continue;
          }

          if (checkCollision(bird, pipe)) {
            gameOver();
            return;
          }

          if (!pipe.passed && pipe.x + PIPE_WIDTH < bird.x) {
            pipe.passed = true;
            let pointsEarned = 1;
            
            // Character-specific point bonuses
            if (bird.character === "golden") {
              pointsEarned++;
            }
            
            // Special ability double points
            if (specialAbilityActive && bird.character === "golden") {
              pointsEarned *= 2;
            }
            
            score += pointsEarned;
            document.getElementById("score").textContent = score;

            checkAchievements();
          }
        }
      }

      function spawnPipe() {
        const gapY = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 100) + 50;
        pipes.push({
          x: CANVAS_WIDTH,
          gapY: gapY,
          passed: false,
        });
      }

      function checkCollision(bird, pipe) {
        let effectiveSize = bird.size;
        
        // Apply character-specific size modifiers
        if (bird.character === "mini") effectiveSize *= 0.6;
        if (bird.character === "giant") effectiveSize *= 1.5;
        
        // Apply special ability size modifiers
        if (specialAbilityActive) {
          switch (bird.character) {
            case "mini":
              effectiveSize *= 0.4; // Even smaller during mini mode
              break;
            case "giant":
              effectiveSize *= 2.0; // Even larger during crash through
              break;
          }
        }

        return (
          bird.x + effectiveSize > pipe.x &&
          bird.x < pipe.x + PIPE_WIDTH &&
          (bird.y < pipe.gapY || bird.y + effectiveSize > pipe.gapY + PIPE_GAP)
        );
      }

      function checkAchievements() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        if (score >= 10 && !unlocked.has("score_10")) {
          unlockAchievement("score_10", "Getting Started");
          unlockCharacter("blue");
        }
        if (score >= 25 && !unlocked.has("score_25")) {
          unlockAchievement("score_25", "Rising Star");
          unlockCharacter("purple");
          unlockBackground("winter");
        }
        if (score >= 50 && !unlocked.has("score_50")) {
          unlockAchievement("score_50", "Bird Master");
          unlockBackground("galaxy");
        }
        if (score >= 75 && !unlocked.has("score_75")) {
          unlockAchievement("score_75", "Advanced Player");
          unlockBackground("autumn");
        }
        if (score >= 100 && !unlocked.has("score_100")) {
          unlockAchievement("score_100", "Legendary Bird");
          unlockBackground("space");
          unlockCharacter("golden");
        }
        if (score >= 150 && !unlocked.has("score_150")) {
          unlockAchievement("score_150", "Master Flier");
          unlockBackground("space");
        }
        if (score >= 200 && !unlocked.has("score_200")) {
          unlockAchievement("score_200", "Ultimate Legend");
          unlockBackground("space");
        }

        if (stats.gamesPlayed === 1 && !unlocked.has("first_flight")) {
          unlockAchievement("first_flight", "First Flight");
          unlockCharacter("blue");
        }
      }

      function unlockAchievement(id, title) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlocked) progress.unlocked = [];
        if (!progress.unlocked.includes(id)) {
          progress.unlocked.push(id);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));

          showAchievementNotification(title);

          console.log(`Achievement unlocked: ${title}`);
        }
      }

      function unlockCharacter(characterId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedCharacters.includes(characterId)) {
          progress.unlockedCharacters.push(characterId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Character unlocked: ${characterId}`);
        }
      }

      function unlockBackground(backgroundId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        if (!progress.unlockedBackgrounds.includes(backgroundId)) {
          progress.unlockedBackgrounds.push(backgroundId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Background unlocked: ${backgroundId}`);
        }
      }

      function showAchievementNotification(title) {
        const notification = document.createElement("div");
        notification.className =
          "fixed top-20 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-3 rounded-full font-bold z-50 animate-bounce";
        notification.textContent = `🏆 ${title} Unlocked!`;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      function gameOver() {
        gameRunning = false;

        const gameDuration = Date.now() - gameStartTime;
        const distance = score * 100;

        if (score > highScore) {
          highScore = score;
          localStorage.setItem("flappyBirdHighScore", highScore);
        }

        saveGameStats(score, gameDuration, distance);

        // Update all display elements
        document.getElementById("finalScore").textContent = score;
        document.getElementById("highScoreDisplay").textContent = highScore;
        
        // Get and display games played
        const stats = JSON.parse(localStorage.getItem("flappyBirdStats") || "{}");
        const gamesPlayed = stats.gamesPlayed || 0;
        document.getElementById("gamesPlayedDisplay").textContent = gamesPlayed;
        
        // Get and display character name
        const characterNames = {
          "default": "Default Bird",
          "blue": "Blue Bird",
          "purple": "Purple Bird",
          "golden": "Golden Bird",
          "rainbow": "Rainbow Bird",
          "ninja": "Ninja Bird",
          "giant": "Giant Bird",
          "mini": "Mini Bird"
        };
        const characterName = characterNames[bird.character] || "Default Bird";
        document.getElementById("characterDisplay").textContent = characterName;

        // Update the special ability text in the game over screen
        const gameOverAbilityText = document.getElementById("gameOverAbilityText");
        if (gameOverAbilityText) {
          if (bird.character === "default") {
            gameOverAbilityText.textContent = "No special abilities";
            gameOverAbilityText.className = "text-xs text-gray-400";
          } else if (specialAbilityActive) {
            gameOverAbilityText.textContent = `ACTIVE!`;
            gameOverAbilityText.className = "text-xs text-green-400 font-bold";
          } else if (specialAbilityCooldown > 0) {
            gameOverAbilityText.textContent = `Ready in: ${Math.ceil(specialAbilityCooldown / 60)}s`;
            gameOverAbilityText.className = "text-xs text-red-400";
          } else {
            gameOverAbilityText.textContent = "Tap lightning bolt to activate";
            gameOverAbilityText.className = "text-xs text-white";
          }
        }

        // Show the enhanced game over screen
        document.getElementById("gameOver").style.display = "block";

        // Stop any current audio and play game over sound
        stopAllAudio();
        playMP3Sound("assets/sounds/8bit3.mp3");
      }

      function saveGameStats(score, duration, distance) {
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
        stats.highScore = Math.max(stats.highScore || 0, score);
        stats.totalScore = (stats.totalScore || 0) + score;
        stats.totalTime = (stats.totalTime || 0) + duration;
        stats.totalDistance = (stats.totalDistance || 0) + distance;

        const today = new Date().toDateString();
        if (!stats.lastPlayed) {
          stats.lastPlayed = today;
          stats.consecutiveDays = 1;
        } else if (stats.lastPlayed !== today) {
          const lastPlayed = new Date(stats.lastPlayed);
          const currentDate = new Date(today);
          const diffTime = currentDate - lastPlayed;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          if (diffDays === 1) {
            stats.consecutiveDays = (stats.consecutiveDays || 0) + 1;
          } else {
            stats.consecutiveDays = 1;
          }
          stats.lastPlayed = today;
        }

        if (score > 0) {
          stats.perfectRuns = (stats.perfectRuns || 0) + 1;
        }

        if (!stats.recentGames) stats.recentGames = [];
        if (!stats.scoreHistory) stats.scoreHistory = [];

        stats.recentGames.unshift({
          score,
          duration,
          distance,
          timestamp: Date.now(),
          character: bird.character,
        });

        stats.scoreHistory.push(score);

        if (stats.recentGames.length > 50) {
          stats.recentGames = stats.recentGames.slice(0, 50);
        }

        localStorage.setItem("flappyBirdStats", JSON.stringify(stats));

        checkAchievementsAfterGame(stats);
      }

      function checkAchievementsAfterGame(stats) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);


        if (stats.gamesPlayed >= 10 && !unlocked.has("games_10")) {
          unlockAchievement("games_10", "Dedicated Player");
          unlockBackground("ocean");
        }
        if (stats.gamesPlayed >= 25 && !unlocked.has("games_25")) {
          unlockAchievement("games_25", "Regular Player");
          unlockBackground("forest");
        }
        if (stats.gamesPlayed >= 50 && !unlocked.has("games_50")) {
          unlockAchievement("games_50", "Veteran Player");
          unlockBackground("mountain");
        }
        if (stats.gamesPlayed >= 100 && !unlocked.has("games_100")) {
          unlockAchievement("games_100", "Ultimate Player");
          unlockBackground("city");
        }

        if (stats.perfectRuns >= 5 && !unlocked.has("perfect_5")) {
          unlockAchievement("perfect_5", "Perfect Player");
          unlockBackground("city");
          unlockCharacter("ninja");
        }
        if (stats.perfectRuns >= 10 && !unlocked.has("perfect_10")) {
          unlockAchievement("perfect_10", "Perfect Master");
          unlockCharacter("ninja");
        }

        if (stats.consecutiveDays >= 7 && !unlocked.has("daily_player")) {
          unlockAchievement("daily_player", "Daily Player");
          unlockBackground("rainbow");
          unlockCharacter("rainbow");
        }

        if (stats.totalDistance >= 10000 && !unlocked.has("distance_10k")) {
          unlockAchievement("distance_10k", "Long Distance Flier");
          unlockBackground("desert");
        }
      }

      function renderBird(includeSpecialEffects = true) {
        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        let effectiveSize = bird.size;
        let effectiveColor = bird.color;
        let useImage = false;

        // Apply character-specific modifiers
        switch (bird.character) {
          case "blue":
            effectiveColor = "#3B82F6";
            effectiveSize *= 0.9;
            useImage = true;
            break;
          case "purple":
            effectiveColor = "#8B5CF6";
            effectiveSize *= 0.8;
            useImage = true;
            break;
          case "mini":
            effectiveSize *= 0.6;
            break;
          case "giant":
            effectiveSize *= 1.5;
            break;
          default:
            useImage = true;
            break;
        }
        
        // Apply special ability size modifiers
        if (specialAbilityActive) {
          switch (bird.character) {
            case "mini":
              effectiveSize *= 0.4; // Even smaller during mini mode
              break;
            case "giant":
              effectiveSize *= 2.0; // Even larger during crash through
              break;
          }
        }

        // Try to use cached character image
        const cachedImage = characterImages[bird.character];
        if (useImage && cachedImage && cachedImage.complete && cachedImage.naturalWidth > 0) {
          try {
            ctx.drawImage(
              cachedImage,
              bird.x,
              bird.y,
              effectiveSize,
              effectiveSize
            );
          } catch (error) {
            console.log(`Error drawing image for ${bird.character}:`, error);
            renderBasicBird(effectiveSize, effectiveColor);
          }
        } else {
          // Fallback to basic shape if no image available
          if (cachedImage) {
            console.log(`Image for ${bird.character} not ready:`, {
              complete: cachedImage.complete,
              naturalWidth: cachedImage.naturalWidth,
              naturalHeight: cachedImage.naturalHeight
            });
          }
          renderBasicBird(effectiveSize, effectiveColor);
        }

        if (includeSpecialEffects) {
          renderSpecialEffects();
        }

        ctx.restore();
      }

      function renderBasicBird(size, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(
          bird.x + size / 2,
          bird.y + size / 2,
          size / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.x + size * 0.7,
          bird.y + size * 0.3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#FFA500";
        ctx.beginPath();
        ctx.ellipse(
          bird.x + size * 0.3,
          bird.y + size * 0.5,
          8,
          4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }

      function renderSpecialEffects() {
        bird.specialEffects.forEach((effect) => {
          switch (effect.type) {
            case "rainbow":
              ctx.strokeStyle = `hsl(${(Date.now() * 0.1) % 360}, 100%, 50%)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 30, 0, Math.PI * 2);
              ctx.stroke();
              break;
            case "stealth":
              ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 40, 0, Math.PI * 2);
              ctx.fill();
              break;
            case "speedBoost":
              ctx.strokeStyle = "#3B82F6";
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 35, 0, Math.PI * 2);
              ctx.stroke();
              // Add speed lines that follow the bird
              ctx.strokeStyle = "#60A5FA";
              ctx.lineWidth = 2;
              for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(effect.x - 40 - i * 10, effect.y + bird.size/2);
                ctx.lineTo(effect.x - 20 - i * 10, effect.y + bird.size/2);
                ctx.stroke();
              }
              break;
            case "agilityBoost":
              ctx.strokeStyle = "#8B5CF6";
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 30, 0, Math.PI * 2);
              ctx.stroke();
              // Add agility sparkles that follow the bird
              ctx.fillStyle = "#A78BFA";
              for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = effect.x + bird.size/2 + Math.cos(angle) * 25;
                const y = effect.y + bird.size/2 + Math.sin(angle) * 25;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
              }
              break;
            case "doublePoints":
              ctx.strokeStyle = "#FBBF24";
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 40, 0, Math.PI * 2);
              ctx.stroke();
              // Add coin effect that follows the bird
              ctx.fillStyle = "#F59E0B";
              ctx.font = "20px Arial";
              ctx.textAlign = "center";
              ctx.fillText("2x", effect.x + bird.size/2, effect.y + bird.size/2 + 5);
              break;
            case "rainbowTrail":
              ctx.strokeStyle = `hsl(${(Date.now() * 0.2) % 360}, 100%, 50%)`;
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 35, 0, Math.PI * 2);
              ctx.stroke();
              // Add rainbow particles that follow the bird
              for (let i = 0; i < 8; i++) {
                const hue = (i / 8) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                const angle = (i / 8) * Math.PI * 2;
                const x = effect.x + bird.size/2 + Math.cos(angle) * 30;
                const y = effect.y + bird.size/2 + Math.sin(angle) * 25;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
              }
              break;
            case "crashThrough":
              ctx.strokeStyle = "#EF4444";
              ctx.lineWidth = 6;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 50, 0, Math.PI * 2);
              ctx.stroke();
              // Add impact effect that follows the bird
              ctx.strokeStyle = "#DC2626";
              ctx.lineWidth = 3;
              for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(effect.x + bird.size/2, effect.y + bird.size/2);
                ctx.lineTo(
                  effect.x + bird.size/2 + Math.cos(angle) * 60,
                  effect.y + bird.size/2 + Math.sin(angle) * 60
                );
                ctx.stroke();
              }
              break;
            case "miniMode":
              ctx.strokeStyle = "#10B981";
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(effect.x + bird.size/2, effect.y + bird.size/2, 25, 0, Math.PI * 2);
              ctx.stroke();
              // Add mini sparkles that follow the bird
              ctx.fillStyle = "#34D399";
              for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = effect.x + bird.size/2 + Math.cos(angle) * 20;
                const y = effect.y + bird.size/2 + Math.sin(angle) * 20;
                ctx.beginPath();
                ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                ctx.fill();
              }
              break;
          }
        });
      }

      function renderPipes() {
        ctx.fillStyle = "#228B22";

        pipes.forEach((pipe) => {
          ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.gapY);

          ctx.fillRect(
            pipe.x,
            pipe.gapY + PIPE_GAP,
            PIPE_WIDTH,
            CANVAS_HEIGHT - pipe.gapY - PIPE_GAP
          );

          ctx.fillStyle = "#006400";
          ctx.fillRect(pipe.x - 5, pipe.gapY - 20, PIPE_WIDTH + 10, 20);
          ctx.fillRect(pipe.x - 5, pipe.gapY + PIPE_GAP, PIPE_WIDTH + 10, 20);
          ctx.fillStyle = "#228B22";
        });
      }

      function renderBackground() {
        const selectedBackground =
          localStorage.getItem("flappyBirdBackground") || "default";
        
        // Fill the entire canvas with background
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Draw clouds
        for (let i = 0; i < 5; i++) {
          const x = ((Date.now() * 0.02 + i * 200) % (CANVAS_WIDTH + 100)) - 50;
          const y = 50 + i * 80;
          drawCloud(x, y, 60 + i * 10);
        }
      }

      function drawCloud(x, y, size) {
        ctx.beginPath();
        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.4, y, size * 0.6, 0, Math.PI * 2);
        ctx.arc(x + size * 0.8, y, size * 0.4, 0, Math.PI * 2);
        ctx.arc(x + size * 0.6, y + size * 0.2, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.2, y + size * 0.1, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      function gameLoop(currentTime = 0) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        updateBird(deltaTime);
        updatePipes(deltaTime);

        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        renderBackground();
        renderPipes();
        renderBird();

        requestAnimationFrame(gameLoop);
      }

      function renderBirdStatic() {
        renderBird(false);
      }

      function renderCountdown() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        renderBackground();

        renderBirdStatic();

        renderPipes();
      }

      window.addEventListener("load", init);
    </script>
  </body>
</html>
