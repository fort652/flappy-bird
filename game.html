<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flappy Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      canvas {
        display: block;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }

      .game-over {
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.85));
        backdrop-filter: blur(20px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        animation: gameOverSlideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        max-width: 90vw;
        width: 400px;
      }

      @keyframes gameOverSlideIn {
        0% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 0;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.05);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .game-over h2 {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 3rem;
        font-weight: 900;
        text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        margin-bottom: 1rem;
        animation: titlePulse 2s ease-in-out infinite;
      }

      @keyframes titlePulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .final-score {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 2rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .score-number {
        background: linear-gradient(135deg, #10b981, #059669);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-weight: 900;
        font-size: 2rem;
      }

      .game-over-buttons {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
      }

      .game-over-button {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        border: none;
        border-radius: 1rem;
        padding: 1rem 2rem;
        font-size: 1.1rem;
        font-weight: 700;
        color: #000;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        box-shadow: 0 8px 25px rgba(251, 191, 36, 0.4);
      }

      .game-over-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        transform: translateX(-100%);
        transition: transform 0.6s ease;
      }

      .game-over-button:hover::before {
        transform: translateX(100%);
      }

      .game-over-button:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 15px 35px rgba(251, 191, 36, 0.6);
      }

      .game-over-button:active {
        transform: translateY(-1px) scale(0.98);
      }

      .button-content {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
      }

      .button-icon {
        width: 1.5rem;
        height: 1.5rem;
        object-fit: contain;
      }

      .stats-summary {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(147, 51, 234, 0.15));
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 1rem;
        padding: 1rem;
        margin-bottom: 1.5rem;
        backdrop-filter: blur(10px);
      }

      .stats-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .stats-row:last-child {
        margin-bottom: 0;
      }

      .stats-label {
        color: #cbd5e1;
        font-size: 0.9rem;
      }

      .stats-value {
        color: #fbbf24;
        font-weight: 700;
        font-size: 1rem;
      }

      .countdown-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        pointer-events: none;
      }

      .countdown-number {
        font-size: 120px;
        font-weight: bold;
        color: #fbbf24;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
        animation: countdownPulse 0.5s ease-out;
      }

      .countdown-text {
        font-size: 32px;
        color: white;
        margin-top: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      @keyframes countdownPulse {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      canvas {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        outline: none;
      }

      * {
        -webkit-tap-highlight-color: transparent;
      }

      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      #gameCanvas {
        display: block;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }
    </style>
  </head>
  <body
    class="m-0 p-0 font-sans bg-gradient-to-br from-sky-300 to-green-200 flex justify-center items-center min-h-screen overflow-hidden"
    style="height: 100vh; min-height: 100vh;"
  >
    <div class="relative rounded-3xl shadow-2xl overflow-hidden w-full h-full">
      <canvas id="gameCanvas" class="w-full h-full"></canvas>

      <div
        class="absolute inset-0 pointer-events-none flex flex-col justify-between p-5"
      >
        <div
          class="text-center text-5xl font-bold text-white drop-shadow-lg mt-5"
          id="score"
        >
          0
        </div>
      </div>

      <div
        class="countdown-overlay"
        id="countdownOverlay"
        style="display: none"
      >
        <div class="countdown-number" id="countdownNumber">3</div>
        <div class="countdown-text">Get Ready!</div>
      </div>

      <div
        class="game-over flex flex-col items-center justify-center gap-6 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white p-8 rounded-2xl text-center hidden"
        id="gameOver"
      >
        <h2 class="text-3xl mb-3 text-red-400">Game Over!</h2>
        
        <div class="final-score">
          Final Score: <span class="score-number" id="finalScore">0</span>
        </div>

        <div class="stats-summary">
          <div class="stats-row">
            <span class="stats-label">High Score:</span>
            <span class="stats-value" id="highScoreDisplay">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Games Played:</span>
            <span class="stats-value" id="gamesPlayedDisplay">0</span>
          </div>
          <div class="stats-row">
            <span class="stats-label">Character:</span>
            <span class="stats-value" id="characterDisplay">Default</span>
          </div>
        </div>

        <div class="game-over-buttons">
          <button 
            onclick="restartGame()" 
            class="game-over-button"
          >
            <div class="button-content">
              <img src="assets/images/reload.png" alt="Restart" class="button-icon">
              Play Again
            </div>
          </button>
          
          <button 
            onclick="goHome()" 
            class="game-over-button"
          >
            <div class="button-content">
              <img src="assets/images/back.png" alt="Home" class="button-icon">
              Go Home
            </div>
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      // No longer needed since we're using custom buttons
    </script>

    <script>
      let CANVAS_WIDTH, CANVAS_HEIGHT;
      const GRAVITY = 0.8;
      const FLAP_SPEED = -10;
      const PIPE_WIDTH = 80;
      const PIPE_GAP = 200;
      const PIPE_SPEED = 5;
      const PIPE_SPAWN_RATE = 2000;

      // Game state
      let canvas, ctx;
      let gameRunning = false;
      let countdownActive = false;
      let countdownValue = 3;
      let score = 0;
      let highScore = localStorage.getItem("flappyBirdHighScore") || 0;
      let gameStartTime = 0;

      const bird = {
        x: 150,
        y: CANVAS_HEIGHT / 2,
        velocity: 0,
        size: 20,
        color: "#FFD700",
        character: "default",
        specialEffects: [],
      };

      let pipes = [];

      let lastTime = 0;
      let pipeSpawnTimer = 0;

      let audioContext;
      let masterVolume = 0.8;
      let soundEffects = true;
      let currentAudioSource = null; // Track current playing audio
      let gameStartAudioSource = null; // Track the game start audio
      let characterImages = {}; // Cache for character images

      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        // Set canvas to full viewport dimensions
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        loadGameSettings();
        loadGameProgress();
        repairProgressData();

        initAudio();
        preloadCharacterImages();

        document.addEventListener("keydown", handleKeyDown);
        canvas.addEventListener("click", handleClick);
        window.addEventListener("resize", handleResize);

        startGame();
      }

      function loadGameSettings() {
        const saved = localStorage.getItem("flappyBirdSettings");
        if (saved) {
          const settings = JSON.parse(saved);
          masterVolume = settings.masterVolume / 100;
          soundEffects = settings.soundEffects;
        }
      }

      function loadGameProgress() {
        // First, ensure default unlocks are available
        ensureDefaultUnlocks();
        
        // Load character from localStorage (this is what the characters page saves to)
        const savedCharacter = localStorage.getItem("flappyBirdCharacter");
        if (savedCharacter) {
          bird.character = savedCharacter;
          console.log(`Loaded saved character: ${savedCharacter}`);
        } else {
          // If no character is saved, use default
          bird.character = "default";
          console.log(`No character saved, using default: ${bird.character}`);
          // Save the default character to localStorage
          localStorage.setItem("flappyBirdCharacter", "default");
        }

        // Also update the progress system to keep it in sync
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        progress.currentCharacter = bird.character;
        localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
        
        console.log(`Final bird character set to: ${bird.character}`);
      }

      function ensureDefaultUnlocks() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        
        // Initialize arrays if they don't exist
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        
        // Always ensure default character is unlocked
        if (!progress.unlockedCharacters.includes("default")) {
          progress.unlockedCharacters.push("default");
        }
        
        // Always ensure default background is unlocked
        if (!progress.unlockedBackgrounds.includes("default")) {
          progress.unlockedBackgrounds.push("default");
        }
        
        // Save the updated progress
        localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
      }

      function repairProgressData() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        
        // Ensure all arrays exist
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        if (!progress.unlocked) progress.unlocked = [];
        
        // Check for any missing default unlocks
        const defaultCharacters = ["default"];
        const defaultBackgrounds = ["default"];
        
        // Add any missing default characters
        defaultCharacters.forEach(char => {
          if (!progress.unlockedCharacters.includes(char)) {
            progress.unlockedCharacters.push(char);
            console.log(`Restored default character: ${char}`);
          }
        });
        
        // Add any missing default backgrounds
        defaultBackgrounds.forEach(bg => {
          if (!progress.unlockedBackgrounds.includes(bg)) {
            progress.unlockedBackgrounds.push(bg);
            console.log(`Restored default background: ${bg}`);
          }
        });
        
        // Save the repaired progress
        localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
        console.log("Progress data repaired:", progress);
      }

      // Debug function - can be called from browser console
      function debugProgress() {
        const progress = localStorage.getItem("flappyBirdProgress");
        const character = localStorage.getItem("flappyBirdCharacter");
        const background = localStorage.getItem("flappyBirdBackground");
        
        console.log("=== PROGRESS DEBUG ===");
        console.log("Progress data:", progress ? JSON.parse(progress) : "None");
        console.log("Selected character:", character);
        console.log("Selected background:", background);
        
        if (progress) {
          const p = JSON.parse(progress);
          console.log("Unlocked characters:", p.unlockedCharacters || []);
          console.log("Unlocked backgrounds:", p.unlockedBackgrounds || []);
          console.log("Unlocked achievements:", p.unlocked || []);
        }
        
        // Try to repair any issues
        repairProgressData();
        
        console.log("=== END DEBUG ===");
      }

      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        } catch (e) {
          console.log("Audio not supported");
        }
      }

      function preloadCharacterImages() {
        const characters = [
          { id: "default", path: "assets/images/tweety.png" },
          { id: "blue", path: "assets/images/blue-bird.png" },
          { id: "purple", path: "assets/images/purple-bird.png" },
          { id: "golden", path: "assets/images/tweety.png" }, // Using tweety as placeholder
          { id: "rainbow", path: "assets/images/tweety.png" }, // Using tweety as placeholder
          { id: "ninja", path: "assets/images/tweety.png" }, // Using tweety as placeholder
          { id: "giant", path: "assets/images/tweety.png" }, // Using tweety as placeholder
          { id: "mini", path: "assets/images/tweety.png" } // Using tweety as placeholder
        ];

        characters.forEach(char => {
          const img = new Image();
          img.onload = () => {
            characterImages[char.id] = img;
            console.log(`Character image loaded: ${char.id}`);
          };
          img.onerror = () => {
            console.log(`Failed to load character image: ${char.path}`);
          };
          img.src = char.path;
        });
      }

      function playMP3Sound(audioPath, onSourceCreated = null) {
        if (!soundEffects || !audioContext) {
          return null;
        }

        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        // Stop any currently playing audio before starting new one
        stopCurrentAudio();

        fetch(audioPath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.arrayBuffer();
          })
          .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
          .then(audioBuffer => {
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = audioBuffer;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(
              0.5 * masterVolume,
              audioContext.currentTime + 0.1
            );

            source.start();
            
            // Store the audio source for potential stopping
            currentAudioSource = source;
            
            // Call the callback if provided
            if (onSourceCreated) {
              onSourceCreated(source);
            }
          })
          .catch(error => {
            // Audio loading failed, continue without sound
          });
      }

      function stopCurrentAudio() {
        if (currentAudioSource) {
          try {
            currentAudioSource.stop();
            currentAudioSource = null;
          } catch (error) {
            currentAudioSource = null;
          }
        }
      }

      function stopGameStartAudio() {
        if (gameStartAudioSource) {
          try {
            gameStartAudioSource.stop();
            gameStartAudioSource = null;
          } catch (error) {
            gameStartAudioSource = null;
          }
        }
      }

      function stopAllAudio() {
        stopCurrentAudio();
        stopGameStartAudio();
      }

      function handleResize() {
        // Update canvas dimensions on window resize
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
      }

      function startGame() {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }

        // Stop any currently playing audio when starting a new game
        stopAllAudio();

        gameRunning = false;
        countdownActive = true;
        countdownValue = 3;
        score = 0;
        gameStartTime = Date.now();
        bird.y = CANVAS_HEIGHT / 2;
        bird.velocity = 0;
        pipes = [];
        pipeSpawnTimer = 0;
        bird.specialEffects = [];

        document.getElementById("score").textContent = "0";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("countdownOverlay").style.display = "block";

        startCountdown();
      }

      function startCountdown() {
        updateCountdownDisplay();

        const countdownRenderLoop = () => {
          if (countdownActive) {
            renderCountdown();
            requestAnimationFrame(countdownRenderLoop);
          }
        };
        countdownRenderLoop();

        const countdownInterval = setInterval(() => {
          countdownValue--;
          updateCountdownDisplay();

          if (countdownValue <= 0) {
            clearInterval(countdownInterval);
            endCountdown();
          }
        }, 1000);
      }

      function updateCountdownDisplay() {
        const countdownNumber = document.getElementById("countdownNumber");
        const countdownText = document.querySelector(".countdown-text");

        if (countdownValue > 0) {
          countdownNumber.textContent = countdownValue;
          countdownText.textContent = "Get Ready!";
        } else {
          countdownNumber.textContent = "GO!";
          countdownText.textContent = "Start Flying!";

          // Play game start sound and track the source
          playMP3Sound("assets/sounds/8bit1.mp3", (source) => {
            gameStartAudioSource = source;
          });
        }
      }

      function endCountdown() {
        countdownActive = false;
        gameRunning = true;

        // Stop the game start audio when the game actually starts
        stopGameStartAudio();

        setTimeout(() => {
          document.getElementById("countdownOverlay").style.display = "none";
        }, 1000);

        gameLoop();
      }

      function restartGame() {
        document.getElementById("gameOver").style.display = "none";

        // Stop any current audio before restarting
        stopCurrentAudio();

        startGame();
      }

      function goHome() {
        // Stop any current audio when leaving the game
        stopCurrentAudio();
        stopGameStartAudio();

        if (window.location.pathname.includes("/")) {
          window.location.href = "../index.html";
        } else {
          window.location.href = "index.html";
        }
      }

      function handleKeyDown(e) {
        if (e.code === "Space" && gameRunning) {
          e.preventDefault();
          flap();
        }
      }

      function handleClick() {
        if (gameRunning) {
          flap();
        }
      }

      function flap() {
        bird.velocity = FLAP_SPEED;

        addSpecialEffects();
      }

      function addSpecialEffects() {
        switch (bird.character) {
          case "rainbow":
            bird.specialEffects.push({
              type: "rainbow",
              x: bird.x,
              y: bird.y,
              life: 30,
            });
            break;
          case "ninja":
            bird.specialEffects.push({
              type: "stealth",
              x: bird.x,
              y: bird.y,
              life: 20,
            });
            break;
        }
      }

      function updateBird(deltaTime) {
        bird.velocity += GRAVITY;
        bird.y += bird.velocity;

        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = 0;
        }
        if (bird.y > CANVAS_HEIGHT - bird.size) {
          gameOver();
        }

        bird.specialEffects = bird.specialEffects.filter((effect) => {
          effect.life--;
          return effect.life > 0;
        });
      }

      function updatePipes(deltaTime) {
        pipeSpawnTimer += deltaTime;
        if (pipeSpawnTimer > PIPE_SPAWN_RATE) {
          spawnPipe();
          pipeSpawnTimer = 0;
        }

        for (let i = pipes.length - 1; i >= 0; i--) {
          const pipe = pipes[i];
          pipe.x -= PIPE_SPEED;

          if (pipe.x + PIPE_WIDTH < 0) {
            pipes.splice(i, 1);
            continue;
          }

          if (checkCollision(bird, pipe)) {
            gameOver();
            return;
          }

          if (!pipe.passed && pipe.x + PIPE_WIDTH < bird.x) {
            pipe.passed = true;
            score++;

            if (bird.character === "golden") {
              score++;
            }

            document.getElementById("score").textContent = score;

            checkAchievements();
          }
        }
      }

      function spawnPipe() {
        const gapY = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 100) + 50;
        pipes.push({
          x: CANVAS_WIDTH,
          gapY: gapY,
          passed: false,
        });
      }

      function checkCollision(bird, pipe) {
        let effectiveSize = bird.size;
        if (bird.character === "mini") effectiveSize *= 0.6;
        if (bird.character === "giant") effectiveSize *= 1.5;

        return (
          bird.x + effectiveSize > pipe.x &&
          bird.x < pipe.x + PIPE_WIDTH &&
          (bird.y < pipe.gapY || bird.y + effectiveSize > pipe.gapY + PIPE_GAP)
        );
      }

      function checkAchievements() {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        if (score >= 10 && !unlocked.has("score_10")) {
          unlockAchievement("score_10", "Getting Started");
          unlockCharacter("blue");
        }
        if (score >= 25 && !unlocked.has("score_25")) {
          unlockAchievement("score_25", "Rising Star");
          unlockCharacter("purple");
          unlockBackground("winter");
        }
        if (score >= 50 && !unlocked.has("score_50")) {
          unlockAchievement("score_50", "Bird Master");
          unlockBackground("galaxy");
        }
        if (score >= 75 && !unlocked.has("score_75")) {
          unlockAchievement("score_75", "Advanced Player");
          unlockBackground("autumn");
        }
        if (score >= 100 && !unlocked.has("score_100")) {
          unlockAchievement("score_100", "Legendary Bird");
          unlockBackground("space");
          unlockCharacter("golden");
        }
        if (score >= 150 && !unlocked.has("score_150")) {
          unlockAchievement("score_150", "Master Flier");
          unlockBackground("space");
        }
        if (score >= 200 && !unlocked.has("score_200")) {
          unlockAchievement("score_200", "Ultimate Legend");
          unlockBackground("space");
        }

        if (stats.gamesPlayed === 1 && !unlocked.has("first_flight")) {
          unlockAchievement("first_flight", "First Flight");
          unlockCharacter("blue");
        }
      }

      function unlockAchievement(id, title) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlocked) progress.unlocked = [];
        if (!progress.unlocked.includes(id)) {
          progress.unlocked.push(id);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));

          showAchievementNotification(title);

          console.log(`Achievement unlocked: ${title}`);
        }
      }

      function unlockCharacter(characterId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedCharacters) progress.unlockedCharacters = [];
        if (!progress.unlockedCharacters.includes(characterId)) {
          progress.unlockedCharacters.push(characterId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Character unlocked: ${characterId}`);
        }
      }

      function unlockBackground(backgroundId) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        if (!progress.unlockedBackgrounds) progress.unlockedBackgrounds = [];
        if (!progress.unlockedBackgrounds.includes(backgroundId)) {
          progress.unlockedBackgrounds.push(backgroundId);
          localStorage.setItem("flappyBirdProgress", JSON.stringify(progress));
          console.log(`Background unlocked: ${backgroundId}`);
        }
      }

      function showAchievementNotification(title) {
        const notification = document.createElement("div");
        notification.className =
          "fixed top-20 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-3 rounded-full font-bold z-50 animate-bounce";
        notification.textContent = `🏆 ${title} Unlocked!`;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      function gameOver() {
        gameRunning = false;

        const gameDuration = Date.now() - gameStartTime;
        const distance = score * 100;

        if (score > highScore) {
          highScore = score;
          localStorage.setItem("flappyBirdHighScore", highScore);
        }

        saveGameStats(score, gameDuration, distance);

        // Update all display elements
        document.getElementById("finalScore").textContent = score;
        document.getElementById("highScoreDisplay").textContent = highScore;
        
        // Get and display games played
        const stats = JSON.parse(localStorage.getItem("flappyBirdStats") || "{}");
        const gamesPlayed = stats.gamesPlayed || 0;
        document.getElementById("gamesPlayedDisplay").textContent = gamesPlayed;
        
        // Get and display character name
        const characterNames = {
          "default": "Default Bird",
          "blue": "Blue Bird",
          "purple": "Purple Bird",
          "golden": "Golden Bird",
          "rainbow": "Rainbow Bird",
          "ninja": "Ninja Bird",
          "giant": "Giant Bird",
          "mini": "Mini Bird"
        };
        const characterName = characterNames[bird.character] || "Default Bird";
        document.getElementById("characterDisplay").textContent = characterName;

        // Show the enhanced game over screen
        document.getElementById("gameOver").style.display = "block";

        // Stop any current audio and play game over sound
        stopAllAudio();
        playMP3Sound("assets/sounds/8bit3.mp3");
      }

      function saveGameStats(score, duration, distance) {
        const stats = JSON.parse(
          localStorage.getItem("flappyBirdStats") || "{}"
        );

        stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
        stats.highScore = Math.max(stats.highScore || 0, score);
        stats.totalScore = (stats.totalScore || 0) + score;
        stats.totalTime = (stats.totalTime || 0) + duration;
        stats.totalDistance = (stats.totalDistance || 0) + distance;

        const today = new Date().toDateString();
        if (!stats.lastPlayed) {
          stats.lastPlayed = today;
          stats.consecutiveDays = 1;
        } else if (stats.lastPlayed !== today) {
          const lastPlayed = new Date(stats.lastPlayed);
          const currentDate = new Date(today);
          const diffTime = currentDate - lastPlayed;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          if (diffDays === 1) {
            stats.consecutiveDays = (stats.consecutiveDays || 0) + 1;
          } else {
            stats.consecutiveDays = 1;
          }
          stats.lastPlayed = today;
        }

        if (score > 0) {
          stats.perfectRuns = (stats.perfectRuns || 0) + 1;
        }

        if (!stats.recentGames) stats.recentGames = [];
        if (!stats.scoreHistory) stats.scoreHistory = [];

        stats.recentGames.unshift({
          score,
          duration,
          distance,
          timestamp: Date.now(),
          character: bird.character,
        });

        stats.scoreHistory.push(score);

        if (stats.recentGames.length > 50) {
          stats.recentGames = stats.recentGames.slice(0, 50);
        }

        localStorage.setItem("flappyBirdStats", JSON.stringify(stats));

        checkAchievementsAfterGame(stats);
      }

      function checkAchievementsAfterGame(stats) {
        const progress = JSON.parse(
          localStorage.getItem("flappyBirdProgress") || "{}"
        );
        const unlocked = new Set(progress.unlocked || []);


        if (stats.gamesPlayed >= 10 && !unlocked.has("games_10")) {
          unlockAchievement("games_10", "Dedicated Player");
          unlockBackground("ocean");
        }
        if (stats.gamesPlayed >= 25 && !unlocked.has("games_25")) {
          unlockAchievement("games_25", "Regular Player");
          unlockBackground("forest");
        }
        if (stats.gamesPlayed >= 50 && !unlocked.has("games_50")) {
          unlockAchievement("games_50", "Veteran Player");
          unlockBackground("mountain");
        }
        if (stats.gamesPlayed >= 100 && !unlocked.has("games_100")) {
          unlockAchievement("games_100", "Ultimate Player");
          unlockBackground("city");
        }

        if (stats.perfectRuns >= 5 && !unlocked.has("perfect_5")) {
          unlockAchievement("perfect_5", "Perfect Player");
          unlockBackground("city");
          unlockCharacter("ninja");
        }
        if (stats.perfectRuns >= 10 && !unlocked.has("perfect_10")) {
          unlockAchievement("perfect_10", "Perfect Master");
          unlockCharacter("ninja");
        }

        if (stats.consecutiveDays >= 7 && !unlocked.has("daily_player")) {
          unlockAchievement("daily_player", "Daily Player");
          unlockBackground("rainbow");
          unlockCharacter("rainbow");
        }

        if (stats.totalDistance >= 10000 && !unlocked.has("distance_10k")) {
          unlockAchievement("distance_10k", "Long Distance Flier");
          unlockBackground("desert");
        }
      }

      function renderBird(includeSpecialEffects = true) {
        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        let effectiveSize = bird.size;
        let effectiveColor = bird.color;
        let useImage = false;
        let characterImage = null;

        console.log(`Rendering bird with character: ${bird.character}`);
        console.log(`Available character images:`, Object.keys(characterImages));

        // Try to load character image if available
        switch (bird.character) {
          case "blue":
            effectiveColor = "#3B82F6";
            effectiveSize *= 0.9;
            useImage = true;
            characterImage = "assets/images/blue-bird.png";
            break;
          case "purple":
            effectiveColor = "#8B5CF6";
            effectiveSize *= 0.8;
            useImage = true;
            characterImage = "assets/images/purple-bird.png";
            break;
          case "mini":
            effectiveSize *= 0.6;
            break;
          case "giant":
            effectiveSize *= 1.5;
            break;
          default:
            useImage = true;
            characterImage = "assets/images/tweety.png";
            break;
        }

        if (useImage && characterImage) {
          const cachedImage = characterImages[bird.character];
          if (cachedImage) {
            console.log(`Using cached image for ${bird.character}`);
            // Use cached image for better performance
            ctx.drawImage(
              cachedImage,
              bird.x,
              bird.y,
              effectiveSize,
              effectiveSize
            );
          } else {
            console.log(`No cached image for ${bird.character}, using fallback`);
            // Fallback to basic shape if image not cached
            renderBasicBird(effectiveSize, effectiveColor);
          }
        } else {
          console.log(`Using basic shape for ${bird.character}`);
          // Use basic shape for characters without images
          renderBasicBird(effectiveSize, effectiveColor);
        }

        if (includeSpecialEffects) {
          renderSpecialEffects();
        }

        ctx.restore();
      }

      function renderBasicBird(size, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(
          bird.x + size / 2,
          bird.y + size / 2,
          size / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.x + size * 0.7,
          bird.y + size * 0.3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#FFA500";
        ctx.beginPath();
        ctx.ellipse(
          bird.x + size * 0.3,
          bird.y + size * 0.5,
          8,
          4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }

      function renderSpecialEffects() {
        bird.specialEffects.forEach((effect) => {
          switch (effect.type) {
            case "rainbow":
              ctx.strokeStyle = `hsl(${(Date.now() * 0.1) % 360}, 100%, 50%)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
              ctx.stroke();
              break;
            case "stealth":
              ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 40, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
        });
      }

      function renderPipes() {
        ctx.fillStyle = "#228B22";

        pipes.forEach((pipe) => {
          ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.gapY);

          ctx.fillRect(
            pipe.x,
            pipe.gapY + PIPE_GAP,
            PIPE_WIDTH,
            CANVAS_HEIGHT - pipe.gapY - PIPE_GAP
          );

          ctx.fillStyle = "#006400";
          ctx.fillRect(pipe.x - 5, pipe.gapY - 20, PIPE_WIDTH + 10, 20);
          ctx.fillRect(pipe.x - 5, pipe.gapY + PIPE_GAP, PIPE_WIDTH + 10, 20);
          ctx.fillStyle = "#228B22";
        });
      }

      function renderBackground() {
        const selectedBackground =
          localStorage.getItem("flappyBirdBackground") || "default";
        
        // Fill the entire canvas with background
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Draw clouds
        for (let i = 0; i < 5; i++) {
          const x = ((Date.now() * 0.02 + i * 200) % (CANVAS_WIDTH + 100)) - 50;
          const y = 50 + i * 80;
          drawCloud(x, y, 60 + i * 10);
        }
      }

      function drawCloud(x, y, size) {
        ctx.beginPath();
        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.4, y, size * 0.6, 0, Math.PI * 2);
        ctx.arc(x + size * 0.8, y, size * 0.4, 0, Math.PI * 2);
        ctx.arc(x + size * 0.6, y + size * 0.2, size * 0.5, 0, Math.PI * 2);
        ctx.arc(x + size * 0.2, y + size * 0.1, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      function gameLoop(currentTime = 0) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        updateBird(deltaTime);
        updatePipes(deltaTime);

        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        renderBackground();
        renderPipes();
        renderBird();

        requestAnimationFrame(gameLoop);
      }

      function renderBirdStatic() {
        renderBird(false);
      }

      function renderCountdown() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1.0;

        renderBackground();

        renderBirdStatic();

        renderPipes();
      }

      window.addEventListener("load", init);
    </script>
  </body>
</html>
